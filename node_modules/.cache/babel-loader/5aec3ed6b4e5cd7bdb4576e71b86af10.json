{"ast":null,"code":"/**\r\n * Copyright (C) 2016 All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are not permitted unless explicitly granted in writing.\r\n *\r\n * Usage and modification rights granted to Schindler AG, Ebikon.\r\n */\nimport Ops from \"../constants/VisibilityOperators\";\nimport uuid from \"node-uuid\";\nimport assert from \"assert\";\nimport { DEFAULT_LANG } from \"../constants/global\";\nimport { FREE_TEXT_VALUE } from \"../utils/options\";\nimport _ from \"lodash\";\nimport moment from \"moment\";\nimport serialize from \"../serialize\";\nexport function readQuestionBlock(node, type, expectedReturnType) {\n  if (getRequiredAttr(node, \"return-type\") !== expectedReturnType) {\n    throw new Error(`return-type of ${type} is not ${expectedReturnType}`);\n  }\n\n  const questionNode = getChildNode(node, \"question\");\n  const labelI18n = getChildNodes(questionNode, \"text\").reduce((acc, textNode) => {\n    return Object.assign({}, acc, {\n      [getAttrWithDefault(textNode, \"lang\", DEFAULT_LANG)]: textNode.textContent\n    });\n  }, {});\n  const descriptionI18n = {\n    [DEFAULT_LANG]: getAttrWithDefault(questionNode, \"description\", undefined)\n  };\n  getChildNodes(questionNode, \"description\").forEach(descriptionNode => {\n    descriptionI18n[getRequiredAttr(descriptionNode, \"lang\")] = descriptionNode.textContent;\n  });\n  const annotatable = hasChildNode(node, \"annotation\");\n  let annotation = null;\n\n  if (annotatable) {\n    const annotationNode = getChildNode(node, \"annotation\");\n    const text = getChildNodes(annotationNode, \"text\").map(n => n.textContent).join(\" \");\n    const imageUrl = hasChildNode(annotationNode, \"image\") ? getRequiredAttr(getChildNode(annotationNode, \"image\"), \"src\") : null;\n\n    if (text || imageUrl) {\n      annotation = {\n        text,\n        imageUrl\n      };\n    }\n  }\n\n  const tags = _.uniq(getAttrWithDefault(node, \"tags\", \"\").split(\",\").map(tag => tag.trim()).filter(tag => tag));\n\n  return {\n    id: getAttrWithDefault(node, \"guid\", uuid.v4()),\n    type: type,\n    annotation,\n    tags,\n    settings: {\n      identifier: getRequiredAttr(node, \"identifier\"),\n      labelI18n: labelI18n,\n      important: getRequiredAttr(node, \"important\") === \"true\",\n      annotatable: annotatable,\n      descriptionI18n: descriptionI18n,\n      images: readImages(questionNode)\n    }\n  };\n}\nexport function readImages(questionNode) {\n  return getChildNodes(questionNode, \"image\").map(n => ({\n    id: uuid.v4(),\n    url: getRequiredAttr(n, \"src\")\n  }));\n}\nexport function getAttrWithDefault(node, attrName, defaultValue) {\n  if (node.hasAttribute(attrName)) {\n    return node.getAttribute(attrName);\n  } else {\n    return defaultValue;\n  }\n}\nexport function getRequiredAttr(node, attrName) {\n  if (node.hasAttribute(attrName)) {\n    return node.getAttribute(attrName);\n  } else {\n    throw new Error(`Expected \"${node.nodeName}\" element to have an attribute \"${attrName}\"`);\n  }\n}\nexport function getValueAttr(node, attrName) {\n  if (node.hasAttribute(attrName)) {\n    return node.getAttribute(attrName);\n  } else {\n    return \"\";\n  }\n}\nexport function hasChildNode(node, childName) {\n  if (node.hasChildNodes()) {\n    for (let i = 0; i < node.childNodes.length; i += 1) {\n      const child = node.childNodes[i];\n\n      if (child.nodeName === childName) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\nexport function getChildNode(node, childName) {\n  if (node.hasChildNodes()) {\n    for (let i = 0; i < node.childNodes.length; i += 1) {\n      const child = node.childNodes[i];\n\n      if (child.nodeName === childName) {\n        return child;\n      }\n    }\n  }\n\n  throw new Error(`Expected element \"${node.nodeName}\" to have a \"${childName}\" child element.`);\n}\nexport function getChildNodes(node, childName) {\n  let result = []; // eslint-disable-line prefer-const\n\n  if (node.hasChildNodes()) {\n    for (let i = 0; i < node.childNodes.length; i += 1) {\n      const child = node.childNodes[i];\n\n      if (child.nodeName === childName) {\n        result.push(child);\n      }\n    }\n  }\n\n  return result;\n}\nexport function appendChild(doc, parentNode, name, textContent = \"\", attributes = {}, isTextContentEncode = true) {\n  const node = doc.createElement(name);\n  parentNode.appendChild(node);\n  Object.keys(attributes).forEach(key => {\n    let value = attributes[key];\n\n    if (value !== null) {\n      if (typeof value === \"string\") {\n        value = value.replace(\"\\n\", \" \");\n      }\n\n      node.setAttribute(key, value);\n    }\n  }); // TODO check how newlines are handled, that is, are they still there when the sfdl is imported?\n\n  if (textContent) {\n    if (isTextContentEncode) node.appendChild(doc.createTextNode(decodeURIComponent(encodeURIComponent(textContent).split(\"%C2%AD\").join(\"\"))));else node.appendChild(doc.createTextNode(textContent));\n  }\n\n  return node;\n}\nexport function appendChildWithLineBreak(doc, parentNode, name, textContent = \"\", attributes = {}) {\n  const node = doc.createElement(name);\n  parentNode.appendChild(node);\n  Object.keys(attributes).forEach(key => {\n    let value = attributes[key];\n\n    if (value !== null) {\n      node.setAttribute(key, value);\n    }\n  }); // TODO check how newlines are handled, that is, are they still there when the sfdl is imported?\n\n  if (textContent) {\n    const textNode = doc.createTextNode(decodeURIComponent(encodeURIComponent(textContent).split(\"%C2%AD\").join(\"\")));\n    node.appendChild(textNode);\n  }\n\n  return node;\n}\nexport function appendQuestionBlock(doc, findField, parentNode, returnType, field) {\n  const {\n    id,\n    settings\n  } = field;\n  const {\n    identifier,\n    labelI18n,\n    important,\n    annotatable,\n    descriptionI18n,\n    visRules,\n    images,\n    authorizationRules,\n    tagRules,\n    printTagRules,\n    buttonDescriptions,\n    externalVisRules,\n    value // value,\n\n  } = settings;\n  const required = settings.hasOwnProperty(\"required\") ? settings.required : false;\n  let initValue = \"\";\n\n  if (value) {\n    if (value.includes(\",\")) {\n      initValue = value.split(\",\");\n    } else {\n      initValue = value;\n    }\n  } else {\n    initValue = \"\";\n  }\n\n  const questionBlock = appendChild(doc, parentNode, \"question_block\", null, {\n    guid: id,\n    identifier: identifier,\n    required: required,\n    important: important,\n    \"return-type\": returnType,\n    value: initValue\n  });\n\n  if (annotatable) {\n    appendChild(doc, questionBlock, \"annotation\");\n  }\n\n  appendVisRules(doc, findField, questionBlock, visRules);\n  appendExtVisRules(doc, findField, questionBlock, externalVisRules);\n  appendAuthorizationRules(doc, questionBlock, field, authorizationRules);\n  appendTagRules(doc, questionBlock, field, tagRules);\n  appendPrintTagRules(doc, questionBlock, field, printTagRules);\n  appendButtonDescriptions(doc, questionBlock, buttonDescriptions);\n  const questionNode = appendChild(doc, questionBlock, \"question\");\n  Object.keys(labelI18n).forEach(lang => {\n    if (typeof labelI18n[lang] !== \"undefined\") {\n      appendChild(doc, questionNode, \"text\", labelI18n[lang], {\n        lang\n      });\n    }\n  });\n  Object.keys(descriptionI18n).forEach(lang => {\n    if (typeof descriptionI18n[lang] !== \"undefined\") {\n      appendChild(doc, questionNode, \"description\", descriptionI18n[lang], {\n        lang\n      });\n    }\n  });\n  appendImages(doc, questionNode, images);\n  return questionBlock;\n}\nexport function appendStaticTagRules(doc, parentNode, field, tagRules) {\n  if (tagRules && tagRules.length > 0) {\n    const tagRulesNode = appendChild(doc, parentNode, \"tag_rules\");\n    tagRules.forEach(({\n      tagName,\n      operatorId,\n      argument,\n      alwaysAdd\n    }) => {\n      assert(tagName); // this must be added earlier in the serialization process\n\n      appendChild(doc, tagRulesNode, \"tag\", null, {\n        name: tagName\n      });\n    });\n  }\n}\nexport function appendImages(doc, parentNode, images) {\n  images.forEach(({\n    url\n  }) => {\n    appendChild(doc, parentNode, \"image\", null, {\n      src: url\n    });\n  });\n}\nexport function appendVisRules(doc, findField, parentNode, visRules) {\n  if (Array.isArray(visRules)) {\n    if (visRules.length > 0) {\n      // const first = visRules[0];\n      const visRulesNode = appendChild(doc, parentNode, \"visibility_rules\", null);\n      visRules.forEach(child => {\n        appendVisRules(doc, findField, visRulesNode, child);\n      });\n    }\n  } else {\n    const {\n      fieldId,\n      operatorId,\n      argument,\n      conjunctionOperator,\n      positionRule\n    } = visRules;\n    const field = findField(fieldId);\n    const {\n      settings\n    } = field;\n    assert(typeof settings.identifier === \"string\");\n    appendChild(doc, parentNode, \"condition\", null, {\n      \"field-identifier\": settings.identifier,\n      operator: operatorId,\n      \"conjunction-operator\": conjunctionOperator,\n      argument: ruleArgumentToString(field, operatorId, argument),\n      positionRule: positionRule\n    });\n  }\n}\nexport function appendTagRules(doc, parentNode, field, tagRules) {\n  if (tagRules && tagRules.length > 0) {\n    const tagRulesNode = appendChild(doc, parentNode, \"tag_rules\");\n    tagRules.forEach(({\n      tagName,\n      operatorId,\n      argument,\n      alwaysAdd\n    }) => {\n      assert(tagName); // this must be added earlier in the serialization process\n\n      if (alwaysAdd) {\n        appendChild(doc, tagRulesNode, \"tag\", null, {\n          name: tagName\n        });\n      } else {\n        argument = ruleArgumentToString(field, operatorId, argument);\n        appendChild(doc, tagRulesNode, \"tag_rule\", null, {\n          tag: tagName,\n          operator: operatorId,\n          argument: argument\n        });\n      }\n    });\n  }\n}\nexport function appendPrintTagRules(doc, parentNode, field, printTagRules) {\n  if (printTagRules && printTagRules.length > 0) {\n    const printTagRulesNode = appendChild(doc, parentNode, \"print_tag_rules\");\n    printTagRules.forEach(({\n      tagName\n    }) => {\n      appendChild(doc, printTagRulesNode, \"tag\", null, {\n        name: tagName\n      });\n    });\n  }\n}\nexport function appendAuthorizationRules(doc, parentNode, field, authorizationRules) {\n  if (authorizationRules && authorizationRules.length > 0) {\n    const authorizationRulesNode = appendChild(doc, parentNode, \"authorization_rules\");\n    authorizationRules.forEach(({\n      authorizationName\n    }) => {\n      appendChild(doc, authorizationRulesNode, \"authorization\", null, {\n        name: authorizationName\n      });\n    });\n  }\n}\nexport function ruleArgumentToString(field, operatorId, argument) {\n  const argType = Ops[operatorId].argType;\n  const {\n    settings\n  } = field;\n\n  if (argType === \"optionId\" && argument !== FREE_TEXT_VALUE) {\n    const {\n      options\n    } = settings;\n    const option = options.find(o => o.value === argument);\n    argument = option.value;\n  }\n\n  if (argType === \"date\") {\n    assert(moment.isMoment(argument));\n    argument = argument.format(\"YYYY-MM-DD\");\n  }\n\n  return argument;\n}\nexport function appendExtVisRules(doc, findField, parentNode, externalVisRules) {\n  if (externalVisRules) {\n    if (Array.isArray(externalVisRules)) {\n      if (externalVisRules.length > 0) {\n        // const first = externalVisRules[0];\n        const extVisRulesNode = appendChild(doc, parentNode, \"external_visibility_rules\", null);\n        externalVisRules.forEach(child => {\n          appendExtVisRules(doc, findField, extVisRulesNode, child);\n        });\n      }\n    } else {\n      const {\n        fieldId,\n        operatorId,\n        argument,\n        conjunctionOperator,\n        fields,\n        form,\n        positionRule\n      } = externalVisRules;\n      const field = fields.find(f => f.id === fieldId);\n      const {\n        settings\n      } = field;\n      assert(typeof settings.identifier === \"string\");\n      const extConditionNode = appendChild(doc, parentNode, \"condition\", null, {\n        \"field-identifier\": settings.identifier,\n        operator: operatorId,\n        \"conjunction-operator\": conjunctionOperator,\n        argument: ruleArgumentToString(field, operatorId, argument),\n        positionRule: positionRule\n      });\n      const externalForm = serialize(form, fields);\n      appendChild(doc, extConditionNode, \"external_form\", externalForm, {}, false);\n    }\n  }\n}\nexport function appendButtonDescriptions(doc, parentNode, buttonDescriptions) {\n  if (buttonDescriptions && buttonDescriptions.length > 0) {\n    const buttonDescriptionsNode = appendChild(doc, parentNode, \"button_descriptions\");\n    buttonDescriptions.forEach(({\n      selectedDescriptionId,\n      selectedButtonId\n    }) => {\n      appendChild(doc, buttonDescriptionsNode, \"button_description\", null, {\n        \"selected-description-id\": selectedDescriptionId,\n        \"selected-button-id\": selectedButtonId\n      });\n    });\n  }\n}\nexport function appendValue(doc, parentNode, value) {\n  if (value && value.length > 0) {\n    appendChild(doc, parentNode, \"value\", value);\n  }\n}","map":{"version":3,"sources":["C:/project/SCF-NI_PM_App/SCF.InstallationQuality/react-client/src/js/sfdl/utils/xml.js"],"names":["Ops","uuid","assert","DEFAULT_LANG","FREE_TEXT_VALUE","_","moment","serialize","readQuestionBlock","node","type","expectedReturnType","getRequiredAttr","Error","questionNode","getChildNode","labelI18n","getChildNodes","reduce","acc","textNode","Object","assign","getAttrWithDefault","textContent","descriptionI18n","undefined","forEach","descriptionNode","annotatable","hasChildNode","annotation","annotationNode","text","map","n","join","imageUrl","tags","uniq","split","tag","trim","filter","id","v4","settings","identifier","important","images","readImages","url","attrName","defaultValue","hasAttribute","getAttribute","nodeName","getValueAttr","childName","hasChildNodes","i","childNodes","length","child","result","push","appendChild","doc","parentNode","name","attributes","isTextContentEncode","createElement","keys","key","value","replace","setAttribute","createTextNode","decodeURIComponent","encodeURIComponent","appendChildWithLineBreak","appendQuestionBlock","findField","returnType","field","visRules","authorizationRules","tagRules","printTagRules","buttonDescriptions","externalVisRules","required","hasOwnProperty","initValue","includes","questionBlock","guid","appendVisRules","appendExtVisRules","appendAuthorizationRules","appendTagRules","appendPrintTagRules","appendButtonDescriptions","lang","appendImages","appendStaticTagRules","tagRulesNode","tagName","operatorId","argument","alwaysAdd","src","Array","isArray","visRulesNode","fieldId","conjunctionOperator","positionRule","operator","ruleArgumentToString","printTagRulesNode","authorizationRulesNode","authorizationName","argType","options","option","find","o","isMoment","format","extVisRulesNode","fields","form","f","extConditionNode","externalForm","buttonDescriptionsNode","selectedDescriptionId","selectedButtonId","appendValue"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (C) 2016 All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are not permitted unless explicitly granted in writing.\r\n *\r\n * Usage and modification rights granted to Schindler AG, Ebikon.\r\n */\r\n\r\nimport Ops from \"../constants/VisibilityOperators\";\r\nimport uuid from \"node-uuid\";\r\nimport assert from \"assert\";\r\nimport { DEFAULT_LANG } from \"../constants/global\";\r\nimport { FREE_TEXT_VALUE } from \"../utils/options\";\r\nimport _ from \"lodash\";\r\nimport moment from \"moment\";\r\nimport serialize from \"../serialize\";\r\n\r\nexport function readQuestionBlock(node, type, expectedReturnType) {\r\n  if (getRequiredAttr(node, \"return-type\") !== expectedReturnType) {\r\n    throw new Error(`return-type of ${type} is not ${expectedReturnType}`);\r\n  }\r\n\r\n  const questionNode = getChildNode(node, \"question\");\r\n\r\n  const labelI18n = getChildNodes(questionNode, \"text\").reduce(\r\n    (acc, textNode) => {\r\n      return Object.assign({}, acc, {\r\n        [getAttrWithDefault(\r\n          textNode,\r\n          \"lang\",\r\n          DEFAULT_LANG\r\n        )]: textNode.textContent,\r\n      });\r\n    },\r\n    {}\r\n  );\r\n\r\n  const descriptionI18n = {\r\n    [DEFAULT_LANG]: getAttrWithDefault(questionNode, \"description\", undefined),\r\n  };\r\n\r\n  getChildNodes(questionNode, \"description\").forEach((descriptionNode) => {\r\n    descriptionI18n[getRequiredAttr(descriptionNode, \"lang\")] =\r\n      descriptionNode.textContent;\r\n  });\r\n\r\n  const annotatable = hasChildNode(node, \"annotation\");\r\n  let annotation = null;\r\n\r\n  if (annotatable) {\r\n    const annotationNode = getChildNode(node, \"annotation\");\r\n\r\n    const text = getChildNodes(annotationNode, \"text\")\r\n      .map((n) => n.textContent)\r\n      .join(\" \");\r\n    const imageUrl = hasChildNode(annotationNode, \"image\")\r\n      ? getRequiredAttr(getChildNode(annotationNode, \"image\"), \"src\")\r\n      : null;\r\n\r\n    if (text || imageUrl) {\r\n      annotation = { text, imageUrl };\r\n    }\r\n  }\r\n\r\n  const tags = _.uniq(\r\n    getAttrWithDefault(node, \"tags\", \"\")\r\n      .split(\",\")\r\n      .map((tag) => tag.trim())\r\n      .filter((tag) => tag)\r\n  );\r\n\r\n  return {\r\n    id: getAttrWithDefault(node, \"guid\", uuid.v4()),\r\n    type: type,\r\n    annotation,\r\n    tags,\r\n    settings: {\r\n      identifier: getRequiredAttr(node, \"identifier\"),\r\n      labelI18n: labelI18n,\r\n      important: getRequiredAttr(node, \"important\") === \"true\",\r\n      annotatable: annotatable,\r\n      descriptionI18n: descriptionI18n,\r\n      images: readImages(questionNode),\r\n    },\r\n  };\r\n}\r\n\r\nexport function readImages(questionNode) {\r\n  return getChildNodes(questionNode, \"image\").map((n) => ({\r\n    id: uuid.v4(),\r\n    url: getRequiredAttr(n, \"src\"),\r\n  }));\r\n}\r\n\r\nexport function getAttrWithDefault(node, attrName, defaultValue) {\r\n  if (node.hasAttribute(attrName)) {\r\n    return node.getAttribute(attrName);\r\n  } else {\r\n    return defaultValue;\r\n  }\r\n}\r\n\r\nexport function getRequiredAttr(node, attrName) {\r\n  if (node.hasAttribute(attrName)) {\r\n    return node.getAttribute(attrName);\r\n  } else {\r\n    throw new Error(\r\n      `Expected \"${node.nodeName}\" element to have an attribute \"${attrName}\"`\r\n    );\r\n  }\r\n}\r\n\r\nexport function getValueAttr(node, attrName) {\r\n  if (node.hasAttribute(attrName)) {\r\n    return node.getAttribute(attrName);\r\n  } else {\r\n    return \"\";\r\n  }\r\n}\r\n\r\nexport function hasChildNode(node, childName) {\r\n  if (node.hasChildNodes()) {\r\n    for (let i = 0; i < node.childNodes.length; i += 1) {\r\n      const child = node.childNodes[i];\r\n      if (child.nodeName === childName) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function getChildNode(node, childName) {\r\n  if (node.hasChildNodes()) {\r\n    for (let i = 0; i < node.childNodes.length; i += 1) {\r\n      const child = node.childNodes[i];\r\n      if (child.nodeName === childName) {\r\n        return child;\r\n      }\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `Expected element \"${node.nodeName}\" to have a \"${childName}\" child element.`\r\n  );\r\n}\r\n\r\nexport function getChildNodes(node, childName) {\r\n  let result = []; // eslint-disable-line prefer-const\r\n\r\n  if (node.hasChildNodes()) {\r\n    for (let i = 0; i < node.childNodes.length; i += 1) {\r\n      const child = node.childNodes[i];\r\n      if (child.nodeName === childName) {\r\n        result.push(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function appendChild(\r\n  doc,\r\n  parentNode,\r\n  name,\r\n  textContent = \"\",\r\n  attributes = {},\r\n  isTextContentEncode = true\r\n) {\r\n  const node = doc.createElement(name);\r\n  parentNode.appendChild(node);\r\n\r\n  Object.keys(attributes).forEach((key) => {\r\n    let value = attributes[key];\r\n    if (value !== null) {\r\n      if (typeof value === \"string\") {\r\n        value = value.replace(\"\\n\", \" \");\r\n      }\r\n      node.setAttribute(key, value);\r\n    }\r\n  });\r\n\r\n  // TODO check how newlines are handled, that is, are they still there when the sfdl is imported?\r\n  if (textContent) {\r\n    if (isTextContentEncode)\r\n      node.appendChild(\r\n        doc.createTextNode(\r\n          decodeURIComponent(\r\n            encodeURIComponent(textContent).split(\"%C2%AD\").join(\"\")\r\n          )\r\n        )\r\n      );\r\n    else node.appendChild(doc.createTextNode(textContent));\r\n  }\r\n\r\n  return node;\r\n}\r\n\r\nexport function appendChildWithLineBreak(\r\n  doc,\r\n  parentNode,\r\n  name,\r\n  textContent = \"\",\r\n  attributes = {}\r\n) {\r\n  const node = doc.createElement(name);\r\n  parentNode.appendChild(node);\r\n\r\n  Object.keys(attributes).forEach((key) => {\r\n    let value = attributes[key];\r\n    if (value !== null) {\r\n      node.setAttribute(key, value);\r\n    }\r\n  });\r\n\r\n  // TODO check how newlines are handled, that is, are they still there when the sfdl is imported?\r\n  if (textContent) {\r\n    const textNode = doc.createTextNode(\r\n      decodeURIComponent(\r\n        encodeURIComponent(textContent).split(\"%C2%AD\").join(\"\")\r\n      )\r\n    );\r\n    node.appendChild(textNode);\r\n  }\r\n\r\n  return node;\r\n}\r\n\r\nexport function appendQuestionBlock(\r\n  doc,\r\n  findField,\r\n  parentNode,\r\n  returnType,\r\n  field\r\n) {\r\n  const { id, settings } = field;\r\n  const {\r\n    identifier,\r\n    labelI18n,\r\n    important,\r\n    annotatable,\r\n    descriptionI18n,\r\n    visRules,\r\n    images,\r\n    authorizationRules,\r\n    tagRules,\r\n    printTagRules,\r\n    buttonDescriptions,\r\n    externalVisRules,\r\n    value,\r\n    // value,\r\n  } = settings;\r\n  const required = settings.hasOwnProperty(\"required\")\r\n    ? settings.required\r\n    : false;\r\n\r\n  let initValue = \"\";\r\n\r\n  if (value) {\r\n    if (value.includes(\",\")) {\r\n      initValue = value.split(\",\");\r\n    } else {\r\n      initValue = value;\r\n    }\r\n  } else {\r\n    initValue = \"\";\r\n  }\r\n\r\n  const questionBlock = appendChild(doc, parentNode, \"question_block\", null, {\r\n    guid: id,\r\n    identifier: identifier,\r\n    required: required,\r\n    important: important,\r\n    \"return-type\": returnType,\r\n    value: initValue,\r\n  });\r\n\r\n  if (annotatable) {\r\n    appendChild(doc, questionBlock, \"annotation\");\r\n  }\r\n\r\n  appendVisRules(doc, findField, questionBlock, visRules);\r\n  appendExtVisRules(doc, findField, questionBlock, externalVisRules);\r\n  appendAuthorizationRules(doc, questionBlock, field, authorizationRules);\r\n  appendTagRules(doc, questionBlock, field, tagRules);\r\n  appendPrintTagRules(doc, questionBlock, field, printTagRules);\r\n  appendButtonDescriptions(doc, questionBlock, buttonDescriptions);\r\n\r\n  const questionNode = appendChild(doc, questionBlock, \"question\");\r\n\r\n  Object.keys(labelI18n).forEach((lang) => {\r\n    if (typeof labelI18n[lang] !== \"undefined\") {\r\n      appendChild(doc, questionNode, \"text\", labelI18n[lang], { lang });\r\n    }\r\n  });\r\n\r\n  Object.keys(descriptionI18n).forEach((lang) => {\r\n    if (typeof descriptionI18n[lang] !== \"undefined\") {\r\n      appendChild(doc, questionNode, \"description\", descriptionI18n[lang], {\r\n        lang,\r\n      });\r\n    }\r\n  });\r\n\r\n  appendImages(doc, questionNode, images);\r\n\r\n  return questionBlock;\r\n}\r\n\r\nexport function appendStaticTagRules(doc, parentNode, field, tagRules) {\r\n  if (tagRules && tagRules.length > 0) {\r\n    const tagRulesNode = appendChild(doc, parentNode, \"tag_rules\");\r\n\r\n    tagRules.forEach(({ tagName, operatorId, argument, alwaysAdd }) => {\r\n      assert(tagName); // this must be added earlier in the serialization process\r\n\r\n      appendChild(doc, tagRulesNode, \"tag\", null, { name: tagName });\r\n    });\r\n  }\r\n}\r\n\r\nexport function appendImages(doc, parentNode, images) {\r\n  images.forEach(({ url }) => {\r\n    appendChild(doc, parentNode, \"image\", null, { src: url });\r\n  });\r\n}\r\n\r\nexport function appendVisRules(doc, findField, parentNode, visRules) {\r\n  if (Array.isArray(visRules)) {\r\n    if (visRules.length > 0) {\r\n      // const first = visRules[0];\r\n      const visRulesNode = appendChild(\r\n        doc,\r\n        parentNode,\r\n        \"visibility_rules\",\r\n        null\r\n      );\r\n\r\n      visRules.forEach((child) => {\r\n        appendVisRules(doc, findField, visRulesNode, child);\r\n      });\r\n    }\r\n  } else {\r\n    const {\r\n      fieldId,\r\n      operatorId,\r\n      argument,\r\n      conjunctionOperator,\r\n      positionRule,\r\n    } = visRules;\r\n    const field = findField(fieldId);\r\n    const { settings } = field;\r\n\r\n    assert(typeof settings.identifier === \"string\");\r\n\r\n    appendChild(doc, parentNode, \"condition\", null, {\r\n      \"field-identifier\": settings.identifier,\r\n      operator: operatorId,\r\n      \"conjunction-operator\": conjunctionOperator,\r\n      argument: ruleArgumentToString(field, operatorId, argument),\r\n      positionRule: positionRule,\r\n    });\r\n  }\r\n}\r\n\r\nexport function appendTagRules(doc, parentNode, field, tagRules) {\r\n  if (tagRules && tagRules.length > 0) {\r\n    const tagRulesNode = appendChild(doc, parentNode, \"tag_rules\");\r\n\r\n    tagRules.forEach(({ tagName, operatorId, argument, alwaysAdd }) => {\r\n      assert(tagName); // this must be added earlier in the serialization process\r\n\r\n      if (alwaysAdd) {\r\n        appendChild(doc, tagRulesNode, \"tag\", null, { name: tagName });\r\n      } else {\r\n        argument = ruleArgumentToString(field, operatorId, argument);\r\n\r\n        appendChild(doc, tagRulesNode, \"tag_rule\", null, {\r\n          tag: tagName,\r\n          operator: operatorId,\r\n          argument: argument,\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport function appendPrintTagRules(doc, parentNode, field, printTagRules) {\r\n  if (printTagRules && printTagRules.length > 0) {\r\n    const printTagRulesNode = appendChild(doc, parentNode, \"print_tag_rules\");\r\n\r\n    printTagRules.forEach(({ tagName }) => {\r\n      appendChild(doc, printTagRulesNode, \"tag\", null, { name: tagName });\r\n    });\r\n  }\r\n}\r\n\r\nexport function appendAuthorizationRules(\r\n  doc,\r\n  parentNode,\r\n  field,\r\n  authorizationRules\r\n) {\r\n  if (authorizationRules && authorizationRules.length > 0) {\r\n    const authorizationRulesNode = appendChild(\r\n      doc,\r\n      parentNode,\r\n      \"authorization_rules\"\r\n    );\r\n\r\n    authorizationRules.forEach(({ authorizationName }) => {\r\n      appendChild(doc, authorizationRulesNode, \"authorization\", null, {\r\n        name: authorizationName,\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nexport function ruleArgumentToString(field, operatorId, argument) {\r\n  const argType = Ops[operatorId].argType;\r\n  const { settings } = field;\r\n\r\n  if (argType === \"optionId\" && argument !== FREE_TEXT_VALUE) {\r\n    const { options } = settings;\r\n    const option = options.find((o) => o.value === argument);\r\n    argument = option.value;\r\n  }\r\n\r\n  if (argType === \"date\") {\r\n    assert(moment.isMoment(argument));\r\n    argument = argument.format(\"YYYY-MM-DD\");\r\n  }\r\n\r\n  return argument;\r\n}\r\n\r\nexport function appendExtVisRules(\r\n  doc,\r\n  findField,\r\n  parentNode,\r\n  externalVisRules\r\n) {\r\n  if (externalVisRules) {\r\n    if (Array.isArray(externalVisRules)) {\r\n      if (externalVisRules.length > 0) {\r\n        // const first = externalVisRules[0];\r\n        const extVisRulesNode = appendChild(\r\n          doc,\r\n          parentNode,\r\n          \"external_visibility_rules\",\r\n          null\r\n        );\r\n\r\n        externalVisRules.forEach((child) => {\r\n          appendExtVisRules(doc, findField, extVisRulesNode, child);\r\n        });\r\n      }\r\n    } else {\r\n      const {\r\n        fieldId,\r\n        operatorId,\r\n        argument,\r\n        conjunctionOperator,\r\n        fields,\r\n        form,\r\n        positionRule,\r\n      } = externalVisRules;\r\n      const field = fields.find((f) => f.id === fieldId);\r\n      const { settings } = field;\r\n\r\n      assert(typeof settings.identifier === \"string\");\r\n\r\n      const extConditionNode = appendChild(doc, parentNode, \"condition\", null, {\r\n        \"field-identifier\": settings.identifier,\r\n        operator: operatorId,\r\n        \"conjunction-operator\": conjunctionOperator,\r\n        argument: ruleArgumentToString(field, operatorId, argument),\r\n        positionRule: positionRule,\r\n      });\r\n      const externalForm = serialize(form, fields);\r\n      appendChild(\r\n        doc,\r\n        extConditionNode,\r\n        \"external_form\",\r\n        externalForm,\r\n        {},\r\n        false\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function appendButtonDescriptions(doc, parentNode, buttonDescriptions) {\r\n  if (buttonDescriptions && buttonDescriptions.length > 0) {\r\n    const buttonDescriptionsNode = appendChild(\r\n      doc,\r\n      parentNode,\r\n      \"button_descriptions\"\r\n    );\r\n\r\n    buttonDescriptions.forEach(\r\n      ({ selectedDescriptionId, selectedButtonId }) => {\r\n        appendChild(doc, buttonDescriptionsNode, \"button_description\", null, {\r\n          \"selected-description-id\": selectedDescriptionId,\r\n          \"selected-button-id\": selectedButtonId,\r\n        });\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nexport function appendValue(doc, parentNode, value) {\r\n  if (value && value.length > 0) {\r\n    appendChild(doc, parentNode, \"value\", value);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}