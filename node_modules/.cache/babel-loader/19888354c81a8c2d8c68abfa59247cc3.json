{"ast":null,"code":"import { SFDL_VERSION, SFDL_MAJOR_VERSION, SFDL_MINOR_VERSION, XSD_REVISION, XSD_VERSION, RETURN_TO_APP_URLS, DEFAULT_LANG } from \"./constants/global\";\nimport { getRequiredAttr, getAttrWithDefault, getChildNode, getChildNodes, hasChildNode, readImages } from \"./utils/xml\";\nimport isValidIdentifier, { removeXMLInvalidChars } from \"./expr/isValidIdentifier\";\nimport FieldTypes from \"./constants/FieldTypes\";\nimport uuid from \"node-uuid\";\nimport assert from \"assert\";\nimport { decrypt } from \"./utils/crypto\";\nimport Ops from \"./constants/VisibilityOperators\";\nimport moment from \"moment\";\nimport { FREE_TEXT_VALUE } from \"./utils/options\";\nimport getDefaultValue from \"./utils/getDefaultValue\";\nimport setupIO from \"./setup\";\nexport default function deserialize(xmlText) {\n  // fix cyclic call setupIO caused by recursive\n  if (!arguments[1]) {\n    setupIO();\n  }\n\n  const parser = new DOMParser();\n  let form;\n  let fields;\n  let fieldsVisRules;\n\n  try {\n    const docNode = parser.parseFromString(removeXMLInvalidChars(xmlText), \"application/xml\").documentElement;\n\n    if (docNode.nodeName === \"form\") {\n      checkRootNode(docNode);\n      checkSfdlVersion(docNode, xmlText);\n      checkXsdVersion(docNode, xmlText);\n      form = readFormMetadata(docNode); // eslint-disable-line prefer-const\n\n      fields = []; // eslint-disable-line prefer-const\n    } else if (docNode.nodeName === \"visibility_rules\") {\n      fieldsVisRules = [];\n    }\n\n    if (docNode.hasChildNodes()) {\n      let pageIndex = 0; // XML sucks\n\n      for (let i = 0; i < docNode.childNodes.length; i += 1) {\n        const child = docNode.childNodes[i];\n\n        switch (child.nodeName) {\n          case \"title\":\n            form.settings.titleI18n[getRequiredAttr(child, \"lang\")] = child.textContent;\n            break;\n\n          case \"description\":\n            form.settings.descriptionI18n[getRequiredAttr(child, \"lang\")] = child.textContent;\n            break;\n\n          case \"logos\":\n            readLogos(form, child);\n            break;\n\n          case \"authorizations\":\n            readAuthorizationUniverse(form, child);\n            break;\n\n          case \"tags\":\n            readTagUniverse(form, child);\n            break;\n\n          case \"print_tags\":\n            readPrintTagUniverse(form, child);\n            break;\n\n          case \"tag_rules_in_filter\":\n            readTagRulesInFilter(form, child);\n            break;\n\n          case \"print_settings\":\n            readPrintSettings(form, child);\n            break;\n\n          case \"languages\":\n            readLanguages(form, child);\n            break;\n\n          case \"email_action\":\n            readEmailAction(form, child);\n            break;\n\n          case \"webdav_action\":\n            readWebdavAction(form, child);\n            break;\n\n          case \"return_to_app_action\":\n            readReturnToAppAction(form, child);\n            break;\n\n          case \"devices\":\n            readDevices(form, child);\n            break;\n\n          case \"meta_datas\":\n            readMetadata(form, child);\n            break;\n\n          case \"blocks\":\n            readBuildingBlocks(form, child);\n            break;\n\n          case \"page\":\n            readPage(fields, child, pageIndex);\n            pageIndex += 1;\n            break;\n\n          case \"question_visibility_rules\":\n            // addVisibilityRules(child, fieldsVisRules);\n            break;\n\n          case \"#comment\":\n          case \"#text\":\n            // ignore this\n            break;\n\n          default:\n            throw new Error(\"Root element contains an illegal child element: \" + child.nodeName);\n        }\n      }\n    }\n\n    if (docNode.nodeName === \"form\") {\n      // Visibility rules:\n      fields.filter(f => FieldTypes[f.type].initialSettings.hasOwnProperty(\"visRules\")).forEach(field => {\n        field.settings.visRules = readVisRules(fields, field.node); //delete field.node;\n      }); // External visibility rules:\n\n      fields.filter(f => FieldTypes[f.type].initialSettings.hasOwnProperty(\"externalVisRules\")).forEach((field, position) => {\n        field.settings.externalVisRules = readExtVisRules(fields, field.node, position);\n      }); // Authorization rules:\n\n      if (form.settings.authorizationUniverse === undefined) {\n        form.settings.authorizationUniverse = [];\n      }\n\n      const authorizationUniverse = form.settings.authorizationUniverse;\n      fields.filter(f => FieldTypes[f.type].initialSettings.hasOwnProperty(\"authorizationRules\")).forEach(field => {\n        field.settings.authorizationRules = readAuthorizationRules(authorizationUniverse, field, field.node); //delete field.node;\n      }); // Tagging rules:\n\n      const tagUniverse = form.settings.tagUniverse;\n      fields.filter(f => FieldTypes[f.type].initialSettings.hasOwnProperty(\"tagRules\")).forEach(field => {\n        field.settings.tagRules = readTagRules(tagUniverse, field, field.node); //delete field.node;\n      }); // Print tagging rules:\n\n      const printTagUniverse = form.settings.printTagUniverse;\n      fields.filter(f => FieldTypes[f.type].initialSettings.hasOwnProperty(\"printTagRules\")).forEach(field => {\n        field.settings.printTagRules = readPrintTagRules(printTagUniverse, field, field.node); //delete field.node;\n      }); // button descriptions:\n\n      fields.filter(f => FieldTypes[f.type].initialSettings.hasOwnProperty(\"buttonDescriptions\")).forEach(field => {\n        field.settings.buttonDescriptions = readButtonDescriptions(fields, field.node); //delete field.node;\n      });\n      return {\n        form,\n        fields\n      };\n    } else {\n      return {\n        fieldsVisRules\n      };\n    }\n  } catch (e) {\n    return {\n      error: e.message\n    };\n  }\n} // some browsers (Chrome, Firefox) does not throw an exception in DOMParser#parseFromString() on\n// invalid input but instead just return a document with a parsererror root-node. So check that\n// the root-node is indeed a nice form-element\n\nfunction checkRootNode(docNode) {\n  if (docNode.nodeName !== \"form\" && docNode.nodeName !== \"visibility_rules\") {\n    throw new Error(\"This doesn't even look like a valid SFDL document!\");\n  }\n}\n\nfunction checkSfdlVersion(docNode, xmlText) {\n  const version = getRequiredAttr(docNode, \"version\");\n  const versionParts = version.split(\".\");\n  const major = Number(versionParts[0]);\n  const minor = Number(versionParts[1]);\n\n  if (major !== SFDL_MAJOR_VERSION || minor > SFDL_MINOR_VERSION) {\n    var stylesheet = determineTransformStylesheet(major, minor, SFDL_MAJOR_VERSION, SFDL_MINOR_VERSION);\n\n    if (stylesheet) {\n      docNode = transformSfdlVersion(docNode, stylesheet, xmlText);\n    } else {\n      throw new Error(`This document is in SFDL format version ${version} but FormBuilder uses ` + `version ${SFDL_VERSION}. Please try to upgrade the version of FormBuilder you are ` + `using, or ask your IT-administrator to convert the form for you.`);\n    }\n  }\n} // xsd-version reflects all changes happened on the xml schema\n// while sfdl only reflects big changes\n\n\nfunction checkXsdVersion(docNode, xmlText) {\n  const xsdVersion = getAttrWithDefault(docNode, \"xsd-version\", \"\");\n\n  if (xsdVersion.length === 0) {\n    return;\n  } // old version\n\n\n  const versionParts = xsdVersion.split(\".\");\n  const major = Number(versionParts[0]);\n  const minor = Number(versionParts[1]);\n  const revision = Number(versionParts[2]);\n\n  if (major > SFDL_MAJOR_VERSION || minor > SFDL_MINOR_VERSION || revision > XSD_REVISION) {\n    throw new Error(`This document is in SFDL format version ${xsdVersion} but FormBuilder uses ` + `version ${XSD_VERSION}. Please try to upgrade the version of FormBuilder you are ` + `using, or ask your IT-administrator to convert the form for you.`);\n  }\n}\n\nfunction determineTransformStylesheet(sourceMajor, sourceMinor, destMajor, destMinor) {\n  var stylesheet = {};\n  stylesheet[\"xslt10to20.xslt\"] = '<?xml version=\"1.0\"?><xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"><xsl:template match=\"@title\" /><xsl:template match=\"@description\" /><xsl:template match=\"@version\" /><xsl:template match=\"@*|node()\"><xsl:copy><xsl:apply-templates select=\"@*|node()\"/></xsl:copy>  </xsl:template><xsl:template match=\"form\">  <xsl:copy><xsl:copy-of select=\"@version|@identifier|@template-version|@include-geo-location|@instance-id|@geo-location|@send-once\"/><xsl:attribute name=\"version\">2.0</xsl:attribute><xsl:choose><xsl:when test=\"not(@template-version)\"><xsl:attribute name=\"template-version\">2.0</xsl:attribute></xsl:when></xsl:choose><title lang=\"English\"><xsl:value-of select=\"@title\" /></title><description lang=\"English\"><xsl:value-of select=\"@description\" /></description><languages><language fallback=\"true\">English</language></languages><xsl:apply-templates select=\"node()\"/></xsl:copy></xsl:template><xsl:template match=\"question\"><xsl:copy> <xsl:apply-templates select=\"@*|node()\"/><description lang=\"English\"><xsl:value-of select=\"@description\" /></description></xsl:copy></xsl:template><xsl:template match=\"text\"><xsl:copy><xsl:attribute name=\"lang\">English</xsl:attribute><xsl:value-of select=\"text()\"/></xsl:copy></xsl:template><xsl:template match=\"section[@title]|section[@description]\"><xsl:copy><xsl:apply-templates select=\"@important\"/><title lang=\"English\"><xsl:value-of select=\"@title\"/></title><description lang=\"English\"><xsl:value-of select=\"@description\"/></description><xsl:apply-templates select=\"node()\"/></xsl:copy></xsl:template></xsl:stylesheet>';\n  const key = \"xslt\" + sourceMajor + sourceMinor + \"to\" + destMajor + destMinor + \".xslt\";\n  return stylesheet[key];\n}\n\nfunction transformSfdlVersion(docNode, stylesheet, xmlText) {\n  const parser = new DOMParser();\n  const xsltProcessor = new XSLTProcessor();\n  var xsltDoc = parser.parseFromString(stylesheet, \"text/xml\");\n  xsltProcessor.importStylesheet(xsltDoc);\n  var newDoc = xsltProcessor.transformToFragment(docNode, document);\n  return newDoc;\n}\n\nfunction readFormMetadata(docNode) {\n  const [lat, long, latLongAccuracy] = getAttrWithDefault(docNode, \"geo-location\", \"\").split(\",\").filter(s => s !== \"\").map(s => Number(s));\n  return {\n    id: getAttrWithDefault(docNode, \"template-guid\", uuid.v4()),\n    instanceId: getAttrWithDefault(docNode, \"instance-id\", undefined) || undefined,\n    templateVersion: getAttrWithDefault(docNode, \"template-version\", \"1.0\"),\n    lat,\n    long,\n    latLongAccuracy,\n    history: [],\n    languages: [DEFAULT_LANG],\n    fallbackLang: DEFAULT_LANG,\n    settings: {\n      identifier: getRequiredAttr(docNode, \"identifier\"),\n      xsdVersion: getAttrWithDefault(docNode, \"xsd-version\", \"\"),\n      status: getAttrWithDefault(docNode, \"status\", \"unknown\"),\n      globalTemplate: getAttrWithDefault(docNode, \"global-template\", \"0\"),\n      titleI18n: {\n        [DEFAULT_LANG]: getAttrWithDefault(docNode, \"title\", undefined)\n      },\n      descriptionI18n: {\n        [DEFAULT_LANG]: getAttrWithDefault(docNode, \"description\", undefined)\n      },\n      includeGeoLocation: getRequiredAttr(docNode, \"include-geo-location\") === \"true\",\n      sendOnce: getAttrWithDefault(docNode, \"send-once\", \"false\") === \"true\",\n      forceSaveMultiLanguage: getAttrWithDefault(docNode, \"force-save-multi-language\", \"false\") === \"true\",\n      tagUniverse: [],\n      printTagUniverse: [],\n      tagRulesInFilter: \"0\",\n      emailAction: {\n        selected: false,\n        receivers: [],\n        attachmentType: \"\"\n      },\n      returnToApp: {\n        selected: false,\n        appId: RETURN_TO_APP_URLS[0]\n      },\n      webDavAction: {\n        selected: false,\n        server: \"\",\n        path: \"\",\n        username: \"\",\n        password: \"\"\n      },\n      metadata: [],\n      blocks: [],\n      logos: [],\n      kgCode: getAttrWithDefault(docNode, \"kg-code\", \"\"),\n      maxNumberOfPictures: getAttrWithDefault(docNode, \"max-number-of-pictures\", \"10\"),\n      printSettings: {\n        printHeader: false,\n        headerText: \"\",\n        printFooter: false,\n        footerText: \"\"\n      }\n    }\n  };\n}\n\nfunction readLogos(form, logosNode) {\n  form.settings.logos = readImages(logosNode);\n}\n\nfunction readAuthorizationUniverse(form, authorizationsNode) {\n  form.settings.authorizationUniverse = getChildNodes(authorizationsNode, \"authorization\").map(authorizationNode => getRequiredAttr(authorizationNode, \"name\")).filter(authorization => isValidIdentifier(authorization)).map(authorization => ({\n    id: uuid.v4(),\n    name: authorization\n  }));\n}\n\nfunction readTagUniverse(form, tagsNode) {\n  form.settings.tagUniverse = getChildNodes(tagsNode, \"tag\").map(tagNode => getRequiredAttr(tagNode, \"name\")).filter(tag => isValidIdentifier(tag)).map(tag => ({\n    id: uuid.v4(),\n    name: tag\n  }));\n}\n\nfunction readPrintTagUniverse(form, tagsNode) {\n  form.settings.printTagUniverse = getChildNodes(tagsNode, \"tag\").map(tagNode => ({\n    name: getRequiredAttr(tagNode, \"name\"),\n    excludeFromOutput: getAttrWithDefault(tagNode, \"exclude-from-output\", \"false\") === \"true\"\n  })).filter(({\n    name\n  }) => isValidIdentifier(name)).map(({\n    name,\n    excludeFromOutput\n  }) => ({\n    id: uuid.v4(),\n    name: name,\n    excludeFromOutput: excludeFromOutput\n  }));\n}\n\nfunction readTagRulesInFilter(form, tagRulesInFilterNode) {\n  form.settings.tagRulesInFilter = tagRulesInFilterNode.textContent;\n}\n\nfunction readPrintSettings(form, printSettingsNode) {\n  const {\n    printSettings\n  } = form.settings;\n  printSettings.printHeader = getAttrWithDefault(printSettingsNode, \"header-required\", \"false\") === \"true\";\n  printSettings.printFooter = getAttrWithDefault(printSettingsNode, \"footer-required\", \"false\") === \"true\";\n\n  if (hasChildNode(printSettingsNode, \"header\")) {\n    const header = getChildNode(printSettingsNode, \"header\");\n    printSettings.headerText = header.textContent;\n  }\n\n  if (hasChildNode(printSettingsNode, \"footer\")) {\n    const footer = getChildNode(printSettingsNode, \"footer\");\n    printSettings.footerText = footer.textContent;\n  }\n}\n\nfunction readLanguages(form, languagesNode) {\n  form.languages = getChildNodes(languagesNode, \"language\").map(langNode => langNode.textContent.trim());\n  assert(form.languages.length > 0);\n  form.fallbackLang = getChildNodes(languagesNode, \"language\").filter(node => getAttrWithDefault(node, \"fallback\", \"false\") === \"true\").map(node => node.textContent.trim())[0] || DEFAULT_LANG;\n}\n\nfunction readEmailAction(form, actionNode) {\n  const {\n    emailAction\n  } = form.settings;\n  emailAction.selected = true;\n  emailAction.receivers = getChildNodes(actionNode, \"receiver\").map(node => node.textContent);\n  emailAction.attachmentType = getAttrWithDefault(actionNode, \"attachment-type\", \"all\");\n}\n\nfunction readWebdavAction(form, actionNode) {\n  const {\n    webDavAction\n  } = form.settings;\n  webDavAction.selected = true;\n  [\"server\", \"path\", \"username\", \"password\"].forEach(attr => {\n    webDavAction[attr] = decrypt(getChildNode(actionNode, attr).textContent);\n  });\n  var fileType = \"\";\n\n  try {\n    fileType = getChildNode(actionNode, \"file-type\").textContent;\n  } catch (error) {\n    console.log(error);\n  }\n\n  if (!fileType || fileType.length === 0) {\n    fileType = \"xml\";\n  }\n\n  webDavAction.fileType = fileType;\n}\n\nfunction readReturnToAppAction(form, actionNode) {\n  const {\n    returnToApp\n  } = form.settings;\n  returnToApp.selected = true;\n  returnToApp.appId = getChildNode(actionNode, \"app_url\").textContent;\n}\n\nfunction readDevices(form, devicesNode) {\n  form.history = getChildNodes(devicesNode, \"device\").map(devNode => ({\n    exportAction: getRequiredAttr(devNode, \"export-action\"),\n    exportDate: new Date(getRequiredAttr(devNode, \"export-date\")),\n    deviceId: devNode.textContent\n  }));\n}\n\nfunction readMetadata(form, metadataNode) {\n  form.settings.metadata = getChildNodes(metadataNode, \"meta_data\").map(item => {\n    return {\n      key: getRequiredAttr(item, \"key\"),\n      value: getRequiredAttr(item, \"value\")\n    };\n  });\n}\n\nfunction readBuildingBlocks(form, blocksNode) {\n  form.settings.blocks = getChildNodes(blocksNode, \"block\").map(blockNode => ({\n    guid: getRequiredAttr(blockNode, \"guid\"),\n    identifier: getRequiredAttr(blockNode, \"identifier\"),\n    title: getRequiredAttr(blockNode, \"title\"),\n    src: getRequiredAttr(blockNode, \"src\"),\n    fields: getChildNodes(blockNode, \"field\").map(fieldNode => getRequiredAttr(fieldNode, \"guid\"))\n  }));\n}\n\nfunction readPage(fields, pageNode, pageIndex) {\n  let pageField = null;\n\n  if (pageIndex !== 0 || hasChildNode(pageNode, \"title\") || pageNode.hasAttribute(\"title\")) {\n    pageField = {\n      id: getAttrWithDefault(pageNode, \"guid\", uuid.v4()),\n      type: \"pageBreak\",\n      settings: {\n        identifier: getAttrWithDefault(pageNode, \"identifier\", \"\"),\n        labelI18n: {\n          [DEFAULT_LANG]: getAttrWithDefault(pageNode, \"title\", undefined)\n        },\n        isCollapsed: false,\n        isTitlePageEnd: getAttrWithDefault(pageNode, \"title-page-end\", \"false\") === \"true\"\n      }\n    };\n    fields.push(pageField);\n  }\n\n  if (pageNode.hasChildNodes()) {\n    let sectionIndex = 0;\n\n    for (let i = 0; i < pageNode.childNodes.length; i += 1) {\n      const child = pageNode.childNodes[i];\n\n      if (child.nodeName === \"#comment\" || child.nodeName === \"#text\") {\n        continue;\n      } // if (child.nodeName !== 'section') {\n      //   throw new Error('page element contains an element that is not a section: ' +\n      //       child.nodeName);\n      // }\n\n\n      if (child.nodeName === \"title\") {\n        assert(pageField);\n        pageField.settings.labelI18n[getRequiredAttr(child, \"lang\")] = child.textContent;\n      } else if ((child.nodeName === \"visibility_rules\" || child.nodeName === \"print_tag_rules\") && child.hasChildNodes()) {\n        assert(pageField);\n        pageField.node = pageNode;\n      } else {\n        readSection(fields, child, sectionIndex);\n        sectionIndex += 1;\n      }\n    }\n  }\n}\n\nfunction readSection(fields, sectionNode, sectionIndex) {\n  let sectionField = null;\n\n  if (sectionIndex !== 0 || hasChildNode(sectionNode, \"title\") || sectionNode.hasAttribute(\"title\") || hasChildNode(sectionNode, \"description\") || sectionNode.hasAttribute(\"description\")) {\n    sectionField = {\n      id: getAttrWithDefault(sectionNode, \"guid\", uuid.v4()),\n      type: \"sectionBreak\",\n      settings: {\n        identifier: getAttrWithDefault(sectionNode, \"identifier\", \"\"),\n        labelI18n: {\n          [DEFAULT_LANG]: getAttrWithDefault(sectionNode, \"title\", undefined)\n        },\n        important: getRequiredAttr(sectionNode, \"important\") === \"true\",\n        descriptionI18n: {\n          [DEFAULT_LANG]: getAttrWithDefault(sectionNode, \"description\", undefined)\n        },\n        isCollapsed: false,\n        qrCodeReader: getAttrWithDefault(sectionNode, \"qr-code-reader\", \"false\") === \"true\"\n      }\n    };\n    fields.push(sectionField);\n  }\n\n  if (sectionNode.hasChildNodes()) {\n    for (let i = 0; i < sectionNode.childNodes.length; i += 1) {\n      const child = sectionNode.childNodes[i];\n\n      if (child.nodeName === \"#text\" || child.nodeName === \"#comment\") {\n        continue;\n      }\n\n      if (child.nodeName === \"title\") {\n        assert(sectionField);\n        sectionField.settings.labelI18n[getRequiredAttr(child, \"lang\")] = child.textContent;\n      } else if (child.nodeName === \"description\") {\n        assert(sectionField);\n        sectionField.settings.descriptionI18n[getRequiredAttr(child, \"lang\")] = child.textContent;\n      } else if (child.nodeName === \"visibility_rules\" || child.nodeName === \"print_tag_rules\") {\n        assert(sectionField);\n        sectionField.node = sectionNode;\n      } else {\n        readField(fields, child);\n      }\n    }\n  }\n} // This reads a form field EXCEPT the visRules. We read those in a second pass because we need to\n// be able to find the referenced field\n\n\nfunction readField(fields, fieldNode) {\n  const types = Object.keys(FieldTypes);\n\n  for (let i = 0; i < types.length; i += 1) {\n    const type = types[i];\n    const fieldIo = FieldTypes[type].io;\n\n    if (fieldIo.canDeserialize(fieldNode)) {\n      const field = fieldIo.deserialize(fieldNode);\n      field.node = fieldNode;\n      fields.push(field);\n      return;\n    }\n  }\n\n  throw new Error(\"Unknown field element: \" + fieldNode.nodeName);\n}\n\nfunction readVisRules(fields, fieldNode) {\n  if (!fieldNode) {\n    return [];\n  }\n\n  if (hasChildNode(fieldNode, \"visibility_rules\")) {\n    const rulesNode = getChildNode(fieldNode, \"visibility_rules\");\n    return parseVisRulesNode(fields, rulesNode);\n  } else {\n    return [];\n  }\n}\n\nfunction parseVisRulesNode(fields, node) {\n  assert(node.nodeName === \"visibility_rules\");\n  let positionRule = 0;\n  const op = getAttrWithDefault(node, \"operator\", \"\");\n  const result = [];\n  result.operator = op;\n\n  if (node.hasChildNodes()) {\n    for (let i = 0; i < node.childNodes.length; i += 1) {\n      const child = node.childNodes[i];\n\n      switch (child.nodeName) {\n        case \"condition\":\n          positionRule = positionRule + 1;\n          var condition = parseConditionNode(fields, child, positionRule); // condition.conjunctionOperator = condition.conjunctionOperator; // store conjuction operator to each condition\n\n          result.push(condition);\n          break;\n\n        case \"visibility_rules\":\n          result.push(parseVisRulesNode(fields, child));\n          break;\n\n        case \"#comment\": // fall thru\n\n        case \"#text\":\n          // ignore this\n          break;\n\n        default:\n          throw new Error(\"visibility_rules element contains illegal child: \" + child.nodeName);\n      }\n    }\n  }\n\n  if (result.length <= 1) {\n    result.operator = \"and\";\n  }\n\n  return result;\n}\n\nfunction parseConditionNode(fields, node, positionRule) {\n  assert(node.nodeName === \"condition\");\n  const otherIdentifier = getRequiredAttr(node, \"field-identifier\");\n  const otherFields = fields.filter(f => f.settings.identifier === otherIdentifier);\n\n  if (otherFields.length !== 1) {\n    throw new Error(\"Invalid SFDL: Form contains multiple fields with the same identifier: \" + otherIdentifier);\n  }\n\n  const otherField = otherFields[0];\n  let operatorId = getRequiredAttr(node, \"operator\");\n  const argType = Ops[operatorId].argType;\n  let conjunctionOperator = getAttrWithDefault(node, \"conjunction-operator\", \"and\");\n  let argument = convertRuleArgument(argType, getRequiredAttr(node, \"argument\"), otherField);\n  let type = getAttrWithDefault(node, \"type\", undefined);\n  let position = parseInt(getAttrWithDefault(node, \"positionRule\", undefined)); // HACK to support opening old versions\n\n  if (operatorId === \"isBool\" && otherField.type === \"naYesNo\") {\n    operatorId = \"isExtBool\";\n    argument = String(argument);\n  }\n\n  return {\n    id: uuid.v4(),\n    fieldId: otherField.id,\n    operatorId: operatorId,\n    argument: argument,\n    conjunctionOperator: conjunctionOperator,\n    type: type,\n    positionRule: position ? position : positionRule,\n    isInternal: true\n  };\n}\n\nfunction convertRuleArgument(argType, argument, field) {\n  switch (argType) {\n    case \"bool\":\n      return argument === \"true\";\n\n    case \"extBool\":\n      assert([\"\", \"na\", \"fixed\", \"true\", \"false\"].includes(argument));\n      return argument;\n\n    case \"date\":\n      return moment(argument, \"YYYY-MM-DD\");\n\n    case \"number\":\n      return Number(argument);\n\n    case \"optionId\":\n      if (argument !== FREE_TEXT_VALUE) {\n        const otherOption = field.settings.options.find(option => option.value === argument);\n        return otherOption.value;\n      } else {\n        return argument;\n      }\n\n    // assert(false);\n    // return 42; // shut up eslint\n\n    case \"string\":\n      return argument;\n\n    default:\n      throw new Error(\"Unknown visibility rule argument type: \" + argType);\n  }\n}\n\nfunction readExtVisRules(fields, fieldNode, position) {\n  if (!fieldNode) {\n    return [];\n  }\n\n  if (hasChildNode(fieldNode, \"external_visibility_rules\")) {\n    const rulesNode = getChildNode(fieldNode, \"external_visibility_rules\");\n    return parseExtVisRulesNode(fields, rulesNode, position);\n  } else {\n    return [];\n  }\n}\n\nfunction parseExtVisRulesNode(fields, node, position) {\n  assert(node.nodeName === \"external_visibility_rules\");\n  let positionRule = getLastPostionOfVisRules(fields, position);\n  const op = getAttrWithDefault(node, \"operator\", \"\");\n  const result = [];\n  result.operator = op;\n\n  if (node.hasChildNodes()) {\n    for (let i = 0; i < node.childNodes.length; i += 1) {\n      const child = node.childNodes[i];\n\n      switch (child.nodeName) {\n        case \"condition\":\n          positionRule = positionRule + 1;\n          var condition = parseExtConditionNode(fields, child, positionRule); // condition.conjunctionOperator = condition.conjunctionOperator; // store conjuction operator to each condition\n\n          result.push(condition);\n          break;\n\n        case \"external_visibility_rules\":\n          result.push(parseExtVisRulesNode(fields, child, position));\n          break;\n\n        case \"#comment\": // fall thru\n\n        case \"#text\":\n          // ignore this\n          break;\n\n        default:\n          throw new Error(\"external_visibility_rules element contains illegal child: \" + child.nodeName);\n      }\n    }\n  }\n\n  if (result.length <= 1) {\n    result.operator = \"and\";\n  }\n\n  return result;\n}\n\nfunction getLastPostionOfVisRules(checkList, position) {\n  const getPositionVR = checkList[position].settings.visRules.map(rules => {\n    return rules.positionRule;\n  });\n  return Math.max(...getPositionVR);\n}\n\nfunction parseExtConditionNode(checkList, node, positionRule) {\n  assert(node.nodeName === \"condition\");\n  const conditionNode = getChildNode(node, \"external_form\");\n  const deserializeResult = deserialize(conditionNode.textContent, true);\n\n  if (deserializeResult.error) {\n    const {\n      error\n    } = deserializeResult;\n    throw new Error(\"external_visibility_rules error: \" + error);\n  }\n\n  const {\n    form,\n    fields\n  } = deserializeResult;\n  const otherIdentifier = getRequiredAttr(node, \"field-identifier\");\n  const otherFields = fields.filter(f => f.settings.identifier === otherIdentifier);\n\n  if (otherFields.length !== 1) {\n    throw new Error(\"Invalid SFDL: Form contains multiple fields with the same identifier: \" + otherIdentifier);\n  }\n\n  const otherField = otherFields[0];\n  let operatorId = getRequiredAttr(node, \"operator\");\n  const argType = Ops[operatorId].argType;\n  let conjunctionOperator = getAttrWithDefault(node, \"conjunction-operator\", \"and\");\n  let argument = convertRuleArgument(argType, getRequiredAttr(node, \"argument\"), otherField);\n  let position = parseInt(getAttrWithDefault(node, \"positionRule\", undefined)); // HACK to support opening old versions\n\n  if (operatorId === \"isBool\" && otherField.type === \"naYesNo\") {\n    operatorId = \"isExtBool\";\n    argument = String(argument);\n  }\n\n  return {\n    id: uuid.v4(),\n    fieldId: otherField.id,\n    operatorId: operatorId,\n    argument: argument,\n    conjunctionOperator: conjunctionOperator,\n    form: form,\n    fields: fields,\n    positionRule: position ? position : positionRule,\n    isInternal: false\n  };\n}\n\nfunction readAuthorizationRules(authorizationUniverse, field, fieldNode) {\n  if (fieldNode === undefined) {\n    return [];\n  }\n\n  const findAuthorizationId = name => {\n    const authorization = authorizationUniverse.find(t => t.name === name);\n    return authorization.id;\n  };\n\n  if (hasChildNode(fieldNode, \"authorization_rules\")) {\n    const rulesNode = getChildNode(fieldNode, \"authorization_rules\");\n    const alwaysAddNodes = getChildNodes(rulesNode, \"authorization\");\n    const alwaysAddRules = alwaysAddNodes.map(tagNode => {\n      const authorizationName = getRequiredAttr(tagNode, \"name\");\n      const authorizationId = findAuthorizationId(authorizationName);\n      return {\n        id: uuid.v4(),\n        authorizationId: authorizationId,\n        authorizationName: authorizationName\n      };\n    });\n    return alwaysAddRules;\n  } else {\n    return [];\n  }\n}\n\nfunction readTagRules(tagUniverse, field, fieldNode) {\n  if (fieldNode === undefined) {\n    return [];\n  }\n\n  const findTagId = name => {\n    const tag = tagUniverse.find(t => t.name === name);\n    assert(tag);\n    return tag.id;\n  };\n\n  if (hasChildNode(fieldNode, \"tag_rules\")) {\n    const rulesNode = getChildNode(fieldNode, \"tag_rules\");\n    const ruleNodes = getChildNodes(rulesNode, \"tag_rule\");\n    const alwaysAddNodes = getChildNodes(rulesNode, \"tag\");\n    const alwaysAddRules = alwaysAddNodes.map(tagNode => {\n      const tagName = getRequiredAttr(tagNode, \"name\");\n      const tagId = findTagId(tagName);\n      const operator = FieldTypes[field.type].applicableOperators[0];\n      return {\n        id: uuid.v4(),\n        tagId: tagId,\n        operatorId: operator.id,\n        argument: getDefaultValue(operator.argType, field),\n        alwaysAdd: true\n      };\n    });\n    const normalRules = ruleNodes.map(ruleNode => {\n      const tagName = getRequiredAttr(ruleNode, \"tag\");\n      const tagId = findTagId(tagName);\n      const operatorId = getRequiredAttr(ruleNode, \"operator\");\n      const argType = Ops[operatorId].argType;\n      const argument = convertRuleArgument(argType, getRequiredAttr(ruleNode, \"argument\"), field);\n      return {\n        id: uuid.v4(),\n        tagId: tagId,\n        operatorId: operatorId,\n        argument: argument,\n        alwaysAdd: false\n      };\n    });\n    return alwaysAddRules.concat(normalRules);\n  } else {\n    return [];\n  }\n}\n\nfunction readPrintTagRules(printTagUniverse, field, fieldNode) {\n  if (fieldNode === undefined) {\n    return [];\n  }\n\n  const findTagId = name => {\n    const tag = printTagUniverse.find(t => t.name === name);\n    return tag.id;\n  };\n\n  if (hasChildNode(fieldNode, \"print_tag_rules\")) {\n    const rulesNode = getChildNode(fieldNode, \"print_tag_rules\");\n    const alwaysAddNodes = getChildNodes(rulesNode, \"tag\");\n    const alwaysAddRules = alwaysAddNodes.map(tagNode => {\n      const tagName = getRequiredAttr(tagNode, \"name\");\n      const tagId = findTagId(tagName);\n      return {\n        id: uuid.v4(),\n        tagId: tagId,\n        tagName: tagName\n      };\n    });\n    return alwaysAddRules;\n  } else {\n    return [];\n  }\n}\n\nfunction readButtonDescriptions(fields, fieldNode) {\n  if (hasChildNode(fieldNode, \"button_descriptions\")) {\n    const buttonDescriptionsNode = getChildNode(fieldNode, \"button_descriptions\");\n    return parseButtonDescriptionNode(fields, buttonDescriptionsNode);\n  } else {\n    return [];\n  }\n}\n\nfunction parseButtonDescriptionNode(fields, node) {\n  assert(node.nodeName === \"button_descriptions\");\n  const result = [];\n\n  if (node.hasChildNodes()) {\n    for (let i = 0; i < node.childNodes.length; i += 1) {\n      const child = node.childNodes[i];\n\n      if (child.nodeName === \"#comment\" || child.nodeName === \"#text\") {\n        continue;\n      }\n\n      const selectedDescriptionId = getRequiredAttr(child, \"selected-description-id\");\n      const selectedButtonId = getRequiredAttr(child, \"selected-button-id\");\n\n      if (child.nodeName === \"button_description\") {\n        result.push({\n          id: uuid.v4(),\n          selectedDescriptionId: selectedDescriptionId,\n          selectedButtonId: selectedButtonId\n        });\n      } else {\n        throw new Error(\"button_descriptions element contains illegal child: \" + child.nodeName);\n      }\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/project/SCF-NI_PM_App/SCF.InstallationQuality/react-client/src/js/sfdl/deserialize.js"],"names":["SFDL_VERSION","SFDL_MAJOR_VERSION","SFDL_MINOR_VERSION","XSD_REVISION","XSD_VERSION","RETURN_TO_APP_URLS","DEFAULT_LANG","getRequiredAttr","getAttrWithDefault","getChildNode","getChildNodes","hasChildNode","readImages","isValidIdentifier","removeXMLInvalidChars","FieldTypes","uuid","assert","decrypt","Ops","moment","FREE_TEXT_VALUE","getDefaultValue","setupIO","deserialize","xmlText","arguments","parser","DOMParser","form","fields","fieldsVisRules","docNode","parseFromString","documentElement","nodeName","checkRootNode","checkSfdlVersion","checkXsdVersion","readFormMetadata","hasChildNodes","pageIndex","i","childNodes","length","child","settings","titleI18n","textContent","descriptionI18n","readLogos","readAuthorizationUniverse","readTagUniverse","readPrintTagUniverse","readTagRulesInFilter","readPrintSettings","readLanguages","readEmailAction","readWebdavAction","readReturnToAppAction","readDevices","readMetadata","readBuildingBlocks","readPage","Error","filter","f","type","initialSettings","hasOwnProperty","forEach","field","visRules","readVisRules","node","position","externalVisRules","readExtVisRules","authorizationUniverse","undefined","authorizationRules","readAuthorizationRules","tagUniverse","tagRules","readTagRules","printTagUniverse","printTagRules","readPrintTagRules","buttonDescriptions","readButtonDescriptions","e","error","message","version","versionParts","split","major","Number","minor","stylesheet","determineTransformStylesheet","transformSfdlVersion","xsdVersion","revision","sourceMajor","sourceMinor","destMajor","destMinor","key","xsltProcessor","XSLTProcessor","xsltDoc","importStylesheet","newDoc","transformToFragment","document","lat","long","latLongAccuracy","s","map","id","v4","instanceId","templateVersion","history","languages","fallbackLang","identifier","status","globalTemplate","includeGeoLocation","sendOnce","forceSaveMultiLanguage","tagRulesInFilter","emailAction","selected","receivers","attachmentType","returnToApp","appId","webDavAction","server","path","username","password","metadata","blocks","logos","kgCode","maxNumberOfPictures","printSettings","printHeader","headerText","printFooter","footerText","logosNode","authorizationsNode","authorizationNode","authorization","name","tagsNode","tagNode","tag","excludeFromOutput","tagRulesInFilterNode","printSettingsNode","header","footer","languagesNode","langNode","trim","actionNode","attr","fileType","console","log","devicesNode","devNode","exportAction","exportDate","Date","deviceId","metadataNode","item","value","blocksNode","blockNode","guid","title","src","fieldNode","pageNode","pageField","hasAttribute","labelI18n","isCollapsed","isTitlePageEnd","push","sectionIndex","readSection","sectionNode","sectionField","important","qrCodeReader","readField","types","Object","keys","fieldIo","io","canDeserialize","rulesNode","parseVisRulesNode","positionRule","op","result","operator","condition","parseConditionNode","otherIdentifier","otherFields","otherField","operatorId","argType","conjunctionOperator","argument","convertRuleArgument","parseInt","String","fieldId","isInternal","includes","otherOption","options","find","option","parseExtVisRulesNode","getLastPostionOfVisRules","parseExtConditionNode","checkList","getPositionVR","rules","Math","max","conditionNode","deserializeResult","findAuthorizationId","t","alwaysAddNodes","alwaysAddRules","authorizationName","authorizationId","findTagId","ruleNodes","tagName","tagId","applicableOperators","alwaysAdd","normalRules","ruleNode","concat","buttonDescriptionsNode","parseButtonDescriptionNode","selectedDescriptionId","selectedButtonId"],"mappings":"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","sourcesContent":["import {\r\n  SFDL_VERSION,\r\n  SFDL_MAJOR_VERSION,\r\n  SFDL_MINOR_VERSION,\r\n  XSD_REVISION,\r\n  XSD_VERSION,\r\n  RETURN_TO_APP_URLS,\r\n  DEFAULT_LANG,\r\n} from \"./constants/global\";\r\nimport {\r\n  getRequiredAttr,\r\n  getAttrWithDefault,\r\n  getChildNode,\r\n  getChildNodes,\r\n  hasChildNode,\r\n  readImages,\r\n} from \"./utils/xml\";\r\nimport isValidIdentifier, {\r\n  removeXMLInvalidChars,\r\n} from \"./expr/isValidIdentifier\";\r\nimport FieldTypes from \"./constants/FieldTypes\";\r\nimport uuid from \"node-uuid\";\r\nimport assert from \"assert\";\r\nimport { decrypt } from \"./utils/crypto\";\r\nimport Ops from \"./constants/VisibilityOperators\";\r\nimport moment from \"moment\";\r\nimport { FREE_TEXT_VALUE } from \"./utils/options\";\r\nimport getDefaultValue from \"./utils/getDefaultValue\";\r\nimport setupIO from \"./setup\";\r\n\r\nexport default function deserialize(xmlText) {\r\n  // fix cyclic call setupIO caused by recursive\r\n  if (!arguments[1]) {\r\n    setupIO();\r\n  }\r\n\r\n  const parser = new DOMParser();\r\n  let form;\r\n  let fields;\r\n  let fieldsVisRules;\r\n\r\n  try {\r\n    const docNode = parser.parseFromString(\r\n      removeXMLInvalidChars(xmlText),\r\n      \"application/xml\"\r\n    ).documentElement;\r\n\r\n    if (docNode.nodeName === \"form\") {\r\n      checkRootNode(docNode);\r\n      checkSfdlVersion(docNode, xmlText);\r\n      checkXsdVersion(docNode, xmlText);\r\n\r\n      form = readFormMetadata(docNode); // eslint-disable-line prefer-const\r\n      fields = []; // eslint-disable-line prefer-const\r\n    } else if (docNode.nodeName === \"visibility_rules\") {\r\n      fieldsVisRules = [];\r\n    }\r\n\r\n    if (docNode.hasChildNodes()) {\r\n      let pageIndex = 0;\r\n\r\n      // XML sucks\r\n      for (let i = 0; i < docNode.childNodes.length; i += 1) {\r\n        const child = docNode.childNodes[i];\r\n        switch (child.nodeName) {\r\n          case \"title\":\r\n            form.settings.titleI18n[getRequiredAttr(child, \"lang\")] =\r\n              child.textContent;\r\n            break;\r\n          case \"description\":\r\n            form.settings.descriptionI18n[getRequiredAttr(child, \"lang\")] =\r\n              child.textContent;\r\n            break;\r\n          case \"logos\":\r\n            readLogos(form, child);\r\n            break;\r\n          case \"authorizations\":\r\n            readAuthorizationUniverse(form, child);\r\n            break;\r\n          case \"tags\":\r\n            readTagUniverse(form, child);\r\n            break;\r\n          case \"print_tags\":\r\n            readPrintTagUniverse(form, child);\r\n            break;\r\n          case \"tag_rules_in_filter\":\r\n            readTagRulesInFilter(form, child);\r\n            break;\r\n          case \"print_settings\":\r\n            readPrintSettings(form, child);\r\n            break;\r\n          case \"languages\":\r\n            readLanguages(form, child);\r\n            break;\r\n          case \"email_action\":\r\n            readEmailAction(form, child);\r\n            break;\r\n          case \"webdav_action\":\r\n            readWebdavAction(form, child);\r\n            break;\r\n          case \"return_to_app_action\":\r\n            readReturnToAppAction(form, child);\r\n            break;\r\n          case \"devices\":\r\n            readDevices(form, child);\r\n            break;\r\n          case \"meta_datas\":\r\n            readMetadata(form, child);\r\n            break;\r\n          case \"blocks\":\r\n            readBuildingBlocks(form, child);\r\n            break;\r\n          case \"page\":\r\n            readPage(fields, child, pageIndex);\r\n            pageIndex += 1;\r\n            break;\r\n          case \"question_visibility_rules\":\r\n            // addVisibilityRules(child, fieldsVisRules);\r\n            break;\r\n          case \"#comment\":\r\n          case \"#text\":\r\n            // ignore this\r\n            break;\r\n          default:\r\n            throw new Error(\r\n              \"Root element contains an illegal child element: \" +\r\n                child.nodeName\r\n            );\r\n        }\r\n      }\r\n    }\r\n\r\n    if (docNode.nodeName === \"form\") {\r\n      // Visibility rules:\r\n      fields\r\n        .filter((f) =>\r\n          FieldTypes[f.type].initialSettings.hasOwnProperty(\"visRules\")\r\n        )\r\n        .forEach((field) => {\r\n          field.settings.visRules = readVisRules(fields, field.node);\r\n          //delete field.node;\r\n        });\r\n\r\n      // External visibility rules:\r\n      fields\r\n        .filter((f) =>\r\n          FieldTypes[f.type].initialSettings.hasOwnProperty(\"externalVisRules\")\r\n        )\r\n        .forEach((field, position) => {\r\n          field.settings.externalVisRules = readExtVisRules(\r\n            fields,\r\n            field.node,\r\n            position\r\n          );\r\n        });\r\n\r\n      // Authorization rules:\r\n      if (form.settings.authorizationUniverse === undefined) {\r\n        form.settings.authorizationUniverse = [];\r\n      }\r\n      const authorizationUniverse = form.settings.authorizationUniverse;\r\n      fields\r\n        .filter((f) =>\r\n          FieldTypes[f.type].initialSettings.hasOwnProperty(\r\n            \"authorizationRules\"\r\n          )\r\n        )\r\n        .forEach((field) => {\r\n          field.settings.authorizationRules = readAuthorizationRules(\r\n            authorizationUniverse,\r\n            field,\r\n            field.node\r\n          );\r\n          //delete field.node;\r\n        });\r\n\r\n      // Tagging rules:\r\n      const tagUniverse = form.settings.tagUniverse;\r\n      fields\r\n        .filter((f) =>\r\n          FieldTypes[f.type].initialSettings.hasOwnProperty(\"tagRules\")\r\n        )\r\n        .forEach((field) => {\r\n          field.settings.tagRules = readTagRules(\r\n            tagUniverse,\r\n            field,\r\n            field.node\r\n          );\r\n          //delete field.node;\r\n        });\r\n\r\n      // Print tagging rules:\r\n      const printTagUniverse = form.settings.printTagUniverse;\r\n      fields\r\n        .filter((f) =>\r\n          FieldTypes[f.type].initialSettings.hasOwnProperty(\"printTagRules\")\r\n        )\r\n        .forEach((field) => {\r\n          field.settings.printTagRules = readPrintTagRules(\r\n            printTagUniverse,\r\n            field,\r\n            field.node\r\n          );\r\n          //delete field.node;\r\n        });\r\n\r\n      // button descriptions:\r\n      fields\r\n        .filter((f) =>\r\n          FieldTypes[f.type].initialSettings.hasOwnProperty(\r\n            \"buttonDescriptions\"\r\n          )\r\n        )\r\n        .forEach((field) => {\r\n          field.settings.buttonDescriptions = readButtonDescriptions(\r\n            fields,\r\n            field.node\r\n          );\r\n          //delete field.node;\r\n        });\r\n\r\n      return { form, fields };\r\n    } else {\r\n      return { fieldsVisRules };\r\n    }\r\n  } catch (e) {\r\n    return { error: e.message };\r\n  }\r\n}\r\n\r\n// some browsers (Chrome, Firefox) does not throw an exception in DOMParser#parseFromString() on\r\n// invalid input but instead just return a document with a parsererror root-node. So check that\r\n// the root-node is indeed a nice form-element\r\nfunction checkRootNode(docNode) {\r\n  if (docNode.nodeName !== \"form\" && docNode.nodeName !== \"visibility_rules\") {\r\n    throw new Error(\"This doesn't even look like a valid SFDL document!\");\r\n  }\r\n}\r\n\r\nfunction checkSfdlVersion(docNode, xmlText) {\r\n  const version = getRequiredAttr(docNode, \"version\");\r\n  const versionParts = version.split(\".\");\r\n  const major = Number(versionParts[0]);\r\n  const minor = Number(versionParts[1]);\r\n\r\n  if (major !== SFDL_MAJOR_VERSION || minor > SFDL_MINOR_VERSION) {\r\n    var stylesheet = determineTransformStylesheet(\r\n      major,\r\n      minor,\r\n      SFDL_MAJOR_VERSION,\r\n      SFDL_MINOR_VERSION\r\n    );\r\n\r\n    if (stylesheet) {\r\n      docNode = transformSfdlVersion(docNode, stylesheet, xmlText);\r\n    } else {\r\n      throw new Error(\r\n        `This document is in SFDL format version ${version} but FormBuilder uses ` +\r\n          `version ${SFDL_VERSION}. Please try to upgrade the version of FormBuilder you are ` +\r\n          `using, or ask your IT-administrator to convert the form for you.`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// xsd-version reflects all changes happened on the xml schema\r\n// while sfdl only reflects big changes\r\nfunction checkXsdVersion(docNode, xmlText) {\r\n  const xsdVersion = getAttrWithDefault(docNode, \"xsd-version\", \"\");\r\n\r\n  if (xsdVersion.length === 0) {\r\n    return;\r\n  } // old version\r\n\r\n  const versionParts = xsdVersion.split(\".\");\r\n  const major = Number(versionParts[0]);\r\n  const minor = Number(versionParts[1]);\r\n  const revision = Number(versionParts[2]);\r\n\r\n  if (\r\n    major > SFDL_MAJOR_VERSION ||\r\n    minor > SFDL_MINOR_VERSION ||\r\n    revision > XSD_REVISION\r\n  ) {\r\n    throw new Error(\r\n      `This document is in SFDL format version ${xsdVersion} but FormBuilder uses ` +\r\n        `version ${XSD_VERSION}. Please try to upgrade the version of FormBuilder you are ` +\r\n        `using, or ask your IT-administrator to convert the form for you.`\r\n    );\r\n  }\r\n}\r\n\r\nfunction determineTransformStylesheet(\r\n  sourceMajor,\r\n  sourceMinor,\r\n  destMajor,\r\n  destMinor\r\n) {\r\n  var stylesheet = {};\r\n\r\n  stylesheet[\"xslt10to20.xslt\"] =\r\n    '<?xml version=\"1.0\"?><xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"><xsl:template match=\"@title\" /><xsl:template match=\"@description\" /><xsl:template match=\"@version\" /><xsl:template match=\"@*|node()\"><xsl:copy><xsl:apply-templates select=\"@*|node()\"/></xsl:copy>  </xsl:template><xsl:template match=\"form\">  <xsl:copy><xsl:copy-of select=\"@version|@identifier|@template-version|@include-geo-location|@instance-id|@geo-location|@send-once\"/><xsl:attribute name=\"version\">2.0</xsl:attribute><xsl:choose><xsl:when test=\"not(@template-version)\"><xsl:attribute name=\"template-version\">2.0</xsl:attribute></xsl:when></xsl:choose><title lang=\"English\"><xsl:value-of select=\"@title\" /></title><description lang=\"English\"><xsl:value-of select=\"@description\" /></description><languages><language fallback=\"true\">English</language></languages><xsl:apply-templates select=\"node()\"/></xsl:copy></xsl:template><xsl:template match=\"question\"><xsl:copy> <xsl:apply-templates select=\"@*|node()\"/><description lang=\"English\"><xsl:value-of select=\"@description\" /></description></xsl:copy></xsl:template><xsl:template match=\"text\"><xsl:copy><xsl:attribute name=\"lang\">English</xsl:attribute><xsl:value-of select=\"text()\"/></xsl:copy></xsl:template><xsl:template match=\"section[@title]|section[@description]\"><xsl:copy><xsl:apply-templates select=\"@important\"/><title lang=\"English\"><xsl:value-of select=\"@title\"/></title><description lang=\"English\"><xsl:value-of select=\"@description\"/></description><xsl:apply-templates select=\"node()\"/></xsl:copy></xsl:template></xsl:stylesheet>';\r\n\r\n  const key =\r\n    \"xslt\" + sourceMajor + sourceMinor + \"to\" + destMajor + destMinor + \".xslt\";\r\n\r\n  return stylesheet[key];\r\n}\r\n\r\nfunction transformSfdlVersion(docNode, stylesheet, xmlText) {\r\n  const parser = new DOMParser();\r\n  const xsltProcessor = new XSLTProcessor();\r\n\r\n  var xsltDoc = parser.parseFromString(stylesheet, \"text/xml\");\r\n  xsltProcessor.importStylesheet(xsltDoc);\r\n\r\n  var newDoc = xsltProcessor.transformToFragment(docNode, document);\r\n\r\n  return newDoc;\r\n}\r\n\r\nfunction readFormMetadata(docNode) {\r\n  const [lat, long, latLongAccuracy] = getAttrWithDefault(\r\n    docNode,\r\n    \"geo-location\",\r\n    \"\"\r\n  )\r\n    .split(\",\")\r\n    .filter((s) => s !== \"\")\r\n    .map((s) => Number(s));\r\n\r\n  return {\r\n    id: getAttrWithDefault(docNode, \"template-guid\", uuid.v4()),\r\n    instanceId:\r\n      getAttrWithDefault(docNode, \"instance-id\", undefined) || undefined,\r\n    templateVersion: getAttrWithDefault(docNode, \"template-version\", \"1.0\"),\r\n    lat,\r\n    long,\r\n    latLongAccuracy,\r\n    history: [],\r\n    languages: [DEFAULT_LANG],\r\n    fallbackLang: DEFAULT_LANG,\r\n    settings: {\r\n      identifier: getRequiredAttr(docNode, \"identifier\"),\r\n      xsdVersion: getAttrWithDefault(docNode, \"xsd-version\", \"\"),\r\n      status: getAttrWithDefault(docNode, \"status\", \"unknown\"),\r\n      globalTemplate: getAttrWithDefault(docNode, \"global-template\", \"0\"),\r\n      titleI18n: {\r\n        [DEFAULT_LANG]: getAttrWithDefault(docNode, \"title\", undefined),\r\n      },\r\n      descriptionI18n: {\r\n        [DEFAULT_LANG]: getAttrWithDefault(docNode, \"description\", undefined),\r\n      },\r\n      includeGeoLocation:\r\n        getRequiredAttr(docNode, \"include-geo-location\") === \"true\",\r\n      sendOnce: getAttrWithDefault(docNode, \"send-once\", \"false\") === \"true\",\r\n      forceSaveMultiLanguage:\r\n        getAttrWithDefault(docNode, \"force-save-multi-language\", \"false\") ===\r\n        \"true\",\r\n      tagUniverse: [],\r\n      printTagUniverse: [],\r\n      tagRulesInFilter: \"0\",\r\n      emailAction: {\r\n        selected: false,\r\n        receivers: [],\r\n        attachmentType: \"\",\r\n      },\r\n      returnToApp: {\r\n        selected: false,\r\n        appId: RETURN_TO_APP_URLS[0],\r\n      },\r\n      webDavAction: {\r\n        selected: false,\r\n        server: \"\",\r\n        path: \"\",\r\n        username: \"\",\r\n        password: \"\",\r\n      },\r\n      metadata: [],\r\n      blocks: [],\r\n      logos: [],\r\n      kgCode: getAttrWithDefault(docNode, \"kg-code\", \"\"),\r\n      maxNumberOfPictures: getAttrWithDefault(\r\n        docNode,\r\n        \"max-number-of-pictures\",\r\n        \"10\"\r\n      ),\r\n      printSettings: {\r\n        printHeader: false,\r\n        headerText: \"\",\r\n        printFooter: false,\r\n        footerText: \"\",\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\nfunction readLogos(form, logosNode) {\r\n  form.settings.logos = readImages(logosNode);\r\n}\r\n\r\nfunction readAuthorizationUniverse(form, authorizationsNode) {\r\n  form.settings.authorizationUniverse = getChildNodes(\r\n    authorizationsNode,\r\n    \"authorization\"\r\n  )\r\n    .map((authorizationNode) => getRequiredAttr(authorizationNode, \"name\"))\r\n    .filter((authorization) => isValidIdentifier(authorization))\r\n    .map((authorization) => ({\r\n      id: uuid.v4(),\r\n      name: authorization,\r\n    }));\r\n}\r\n\r\nfunction readTagUniverse(form, tagsNode) {\r\n  form.settings.tagUniverse = getChildNodes(tagsNode, \"tag\")\r\n    .map((tagNode) => getRequiredAttr(tagNode, \"name\"))\r\n    .filter((tag) => isValidIdentifier(tag))\r\n    .map((tag) => ({\r\n      id: uuid.v4(),\r\n      name: tag,\r\n    }));\r\n}\r\n\r\nfunction readPrintTagUniverse(form, tagsNode) {\r\n  form.settings.printTagUniverse = getChildNodes(tagsNode, \"tag\")\r\n    .map((tagNode) => ({\r\n      name: getRequiredAttr(tagNode, \"name\"),\r\n      excludeFromOutput:\r\n        getAttrWithDefault(tagNode, \"exclude-from-output\", \"false\") === \"true\",\r\n    }))\r\n    .filter(({ name }) => isValidIdentifier(name))\r\n    .map(({ name, excludeFromOutput }) => ({\r\n      id: uuid.v4(),\r\n      name: name,\r\n      excludeFromOutput: excludeFromOutput,\r\n    }));\r\n}\r\n\r\nfunction readTagRulesInFilter(form, tagRulesInFilterNode) {\r\n  form.settings.tagRulesInFilter = tagRulesInFilterNode.textContent;\r\n}\r\n\r\nfunction readPrintSettings(form, printSettingsNode) {\r\n  const { printSettings } = form.settings;\r\n\r\n  printSettings.printHeader =\r\n    getAttrWithDefault(printSettingsNode, \"header-required\", \"false\") ===\r\n    \"true\";\r\n  printSettings.printFooter =\r\n    getAttrWithDefault(printSettingsNode, \"footer-required\", \"false\") ===\r\n    \"true\";\r\n\r\n  if (hasChildNode(printSettingsNode, \"header\")) {\r\n    const header = getChildNode(printSettingsNode, \"header\");\r\n    printSettings.headerText = header.textContent;\r\n  }\r\n\r\n  if (hasChildNode(printSettingsNode, \"footer\")) {\r\n    const footer = getChildNode(printSettingsNode, \"footer\");\r\n    printSettings.footerText = footer.textContent;\r\n  }\r\n}\r\n\r\nfunction readLanguages(form, languagesNode) {\r\n  form.languages = getChildNodes(languagesNode, \"language\").map((langNode) =>\r\n    langNode.textContent.trim()\r\n  );\r\n\r\n  assert(form.languages.length > 0);\r\n\r\n  form.fallbackLang =\r\n    getChildNodes(languagesNode, \"language\")\r\n      .filter(\r\n        (node) => getAttrWithDefault(node, \"fallback\", \"false\") === \"true\"\r\n      )\r\n      .map((node) => node.textContent.trim())[0] || DEFAULT_LANG;\r\n}\r\n\r\nfunction readEmailAction(form, actionNode) {\r\n  const { emailAction } = form.settings;\r\n\r\n  emailAction.selected = true;\r\n  emailAction.receivers = getChildNodes(actionNode, \"receiver\").map(\r\n    (node) => node.textContent\r\n  );\r\n  emailAction.attachmentType = getAttrWithDefault(\r\n    actionNode,\r\n    \"attachment-type\",\r\n    \"all\"\r\n  );\r\n}\r\n\r\nfunction readWebdavAction(form, actionNode) {\r\n  const { webDavAction } = form.settings;\r\n\r\n  webDavAction.selected = true;\r\n  [\"server\", \"path\", \"username\", \"password\"].forEach((attr) => {\r\n    webDavAction[attr] = decrypt(getChildNode(actionNode, attr).textContent);\r\n  });\r\n\r\n  var fileType = \"\";\r\n  try {\r\n    fileType = getChildNode(actionNode, \"file-type\").textContent;\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n\r\n  if (!fileType || fileType.length === 0) {\r\n    fileType = \"xml\";\r\n  }\r\n  webDavAction.fileType = fileType;\r\n}\r\n\r\nfunction readReturnToAppAction(form, actionNode) {\r\n  const { returnToApp } = form.settings;\r\n\r\n  returnToApp.selected = true;\r\n  returnToApp.appId = getChildNode(actionNode, \"app_url\").textContent;\r\n}\r\n\r\nfunction readDevices(form, devicesNode) {\r\n  form.history = getChildNodes(devicesNode, \"device\").map((devNode) => ({\r\n    exportAction: getRequiredAttr(devNode, \"export-action\"),\r\n    exportDate: new Date(getRequiredAttr(devNode, \"export-date\")),\r\n    deviceId: devNode.textContent,\r\n  }));\r\n}\r\n\r\nfunction readMetadata(form, metadataNode) {\r\n  form.settings.metadata = getChildNodes(metadataNode, \"meta_data\").map(\r\n    (item) => {\r\n      return {\r\n        key: getRequiredAttr(item, \"key\"),\r\n        value: getRequiredAttr(item, \"value\"),\r\n      };\r\n    }\r\n  );\r\n}\r\n\r\nfunction readBuildingBlocks(form, blocksNode) {\r\n  form.settings.blocks = getChildNodes(blocksNode, \"block\").map(\r\n    (blockNode) => ({\r\n      guid: getRequiredAttr(blockNode, \"guid\"),\r\n      identifier: getRequiredAttr(blockNode, \"identifier\"),\r\n      title: getRequiredAttr(blockNode, \"title\"),\r\n      src: getRequiredAttr(blockNode, \"src\"),\r\n      fields: getChildNodes(blockNode, \"field\").map((fieldNode) =>\r\n        getRequiredAttr(fieldNode, \"guid\")\r\n      ),\r\n    })\r\n  );\r\n}\r\n\r\nfunction readPage(fields, pageNode, pageIndex) {\r\n  let pageField = null;\r\n\r\n  if (\r\n    pageIndex !== 0 ||\r\n    hasChildNode(pageNode, \"title\") ||\r\n    pageNode.hasAttribute(\"title\")\r\n  ) {\r\n    pageField = {\r\n      id: getAttrWithDefault(pageNode, \"guid\", uuid.v4()),\r\n      type: \"pageBreak\",\r\n      settings: {\r\n        identifier: getAttrWithDefault(pageNode, \"identifier\", \"\"),\r\n        labelI18n: {\r\n          [DEFAULT_LANG]: getAttrWithDefault(pageNode, \"title\", undefined),\r\n        },\r\n        isCollapsed: false,\r\n        isTitlePageEnd:\r\n          getAttrWithDefault(pageNode, \"title-page-end\", \"false\") === \"true\",\r\n      },\r\n    };\r\n\r\n    fields.push(pageField);\r\n  }\r\n\r\n  if (pageNode.hasChildNodes()) {\r\n    let sectionIndex = 0;\r\n    for (let i = 0; i < pageNode.childNodes.length; i += 1) {\r\n      const child = pageNode.childNodes[i];\r\n\r\n      if (child.nodeName === \"#comment\" || child.nodeName === \"#text\") {\r\n        continue;\r\n      }\r\n\r\n      // if (child.nodeName !== 'section') {\r\n      //   throw new Error('page element contains an element that is not a section: ' +\r\n      //       child.nodeName);\r\n      // }\r\n\r\n      if (child.nodeName === \"title\") {\r\n        assert(pageField);\r\n        pageField.settings.labelI18n[getRequiredAttr(child, \"lang\")] =\r\n          child.textContent;\r\n      } else if (\r\n        (child.nodeName === \"visibility_rules\" ||\r\n          child.nodeName === \"print_tag_rules\") &&\r\n        child.hasChildNodes()\r\n      ) {\r\n        assert(pageField);\r\n        pageField.node = pageNode;\r\n      } else {\r\n        readSection(fields, child, sectionIndex);\r\n        sectionIndex += 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction readSection(fields, sectionNode, sectionIndex) {\r\n  let sectionField = null;\r\n\r\n  if (\r\n    sectionIndex !== 0 ||\r\n    hasChildNode(sectionNode, \"title\") ||\r\n    sectionNode.hasAttribute(\"title\") ||\r\n    hasChildNode(sectionNode, \"description\") ||\r\n    sectionNode.hasAttribute(\"description\")\r\n  ) {\r\n    sectionField = {\r\n      id: getAttrWithDefault(sectionNode, \"guid\", uuid.v4()),\r\n      type: \"sectionBreak\",\r\n      settings: {\r\n        identifier: getAttrWithDefault(sectionNode, \"identifier\", \"\"),\r\n        labelI18n: {\r\n          [DEFAULT_LANG]: getAttrWithDefault(sectionNode, \"title\", undefined),\r\n        },\r\n        important: getRequiredAttr(sectionNode, \"important\") === \"true\",\r\n        descriptionI18n: {\r\n          [DEFAULT_LANG]: getAttrWithDefault(\r\n            sectionNode,\r\n            \"description\",\r\n            undefined\r\n          ),\r\n        },\r\n        isCollapsed: false,\r\n        qrCodeReader:\r\n          getAttrWithDefault(sectionNode, \"qr-code-reader\", \"false\") === \"true\",\r\n      },\r\n    };\r\n\r\n    fields.push(sectionField);\r\n  }\r\n\r\n  if (sectionNode.hasChildNodes()) {\r\n    for (let i = 0; i < sectionNode.childNodes.length; i += 1) {\r\n      const child = sectionNode.childNodes[i];\r\n\r\n      if (child.nodeName === \"#text\" || child.nodeName === \"#comment\") {\r\n        continue;\r\n      }\r\n\r\n      if (child.nodeName === \"title\") {\r\n        assert(sectionField);\r\n        sectionField.settings.labelI18n[getRequiredAttr(child, \"lang\")] =\r\n          child.textContent;\r\n      } else if (child.nodeName === \"description\") {\r\n        assert(sectionField);\r\n        sectionField.settings.descriptionI18n[getRequiredAttr(child, \"lang\")] =\r\n          child.textContent;\r\n      } else if (\r\n        child.nodeName === \"visibility_rules\" ||\r\n        child.nodeName === \"print_tag_rules\"\r\n      ) {\r\n        assert(sectionField);\r\n        sectionField.node = sectionNode;\r\n      } else {\r\n        readField(fields, child);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// This reads a form field EXCEPT the visRules. We read those in a second pass because we need to\r\n// be able to find the referenced field\r\nfunction readField(fields, fieldNode) {\r\n  const types = Object.keys(FieldTypes);\r\n\r\n  for (let i = 0; i < types.length; i += 1) {\r\n    const type = types[i];\r\n    const fieldIo = FieldTypes[type].io;\r\n\r\n    if (fieldIo.canDeserialize(fieldNode)) {\r\n      const field = fieldIo.deserialize(fieldNode);\r\n      field.node = fieldNode;\r\n      fields.push(field);\r\n      return;\r\n    }\r\n  }\r\n\r\n  throw new Error(\"Unknown field element: \" + fieldNode.nodeName);\r\n}\r\n\r\nfunction readVisRules(fields, fieldNode) {\r\n  if (!fieldNode) {\r\n    return [];\r\n  }\r\n\r\n  if (hasChildNode(fieldNode, \"visibility_rules\")) {\r\n    const rulesNode = getChildNode(fieldNode, \"visibility_rules\");\r\n\r\n    return parseVisRulesNode(fields, rulesNode);\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction parseVisRulesNode(fields, node) {\r\n  assert(node.nodeName === \"visibility_rules\");\r\n\r\n  let positionRule = 0;\r\n  const op = getAttrWithDefault(node, \"operator\", \"\");\r\n\r\n  const result = [];\r\n  result.operator = op;\r\n\r\n  if (node.hasChildNodes()) {\r\n    for (let i = 0; i < node.childNodes.length; i += 1) {\r\n      const child = node.childNodes[i];\r\n\r\n      switch (child.nodeName) {\r\n        case \"condition\":\r\n          positionRule = positionRule + 1;\r\n          var condition = parseConditionNode(fields, child, positionRule);\r\n          // condition.conjunctionOperator = condition.conjunctionOperator; // store conjuction operator to each condition\r\n          result.push(condition);\r\n          break;\r\n        case \"visibility_rules\":\r\n          result.push(parseVisRulesNode(fields, child));\r\n          break;\r\n        case \"#comment\": // fall thru\r\n        case \"#text\":\r\n          // ignore this\r\n          break;\r\n        default:\r\n          throw new Error(\r\n            \"visibility_rules element contains illegal child: \" + child.nodeName\r\n          );\r\n      }\r\n    }\r\n  }\r\n\r\n  if (result.length <= 1) {\r\n    result.operator = \"and\";\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction parseConditionNode(fields, node, positionRule) {\r\n  assert(node.nodeName === \"condition\");\r\n\r\n  const otherIdentifier = getRequiredAttr(node, \"field-identifier\");\r\n  const otherFields = fields.filter(\r\n    (f) => f.settings.identifier === otherIdentifier\r\n  );\r\n  if (otherFields.length !== 1) {\r\n    throw new Error(\r\n      \"Invalid SFDL: Form contains multiple fields with the same identifier: \" +\r\n        otherIdentifier\r\n    );\r\n  }\r\n  const otherField = otherFields[0];\r\n\r\n  let operatorId = getRequiredAttr(node, \"operator\");\r\n  const argType = Ops[operatorId].argType;\r\n\r\n  let conjunctionOperator = getAttrWithDefault(\r\n    node,\r\n    \"conjunction-operator\",\r\n    \"and\"\r\n  );\r\n  let argument = convertRuleArgument(\r\n    argType,\r\n    getRequiredAttr(node, \"argument\"),\r\n    otherField\r\n  );\r\n\r\n  let type = getAttrWithDefault(node, \"type\", undefined);\r\n\r\n  let position = parseInt(getAttrWithDefault(node, \"positionRule\", undefined));\r\n\r\n  // HACK to support opening old versions\r\n  if (operatorId === \"isBool\" && otherField.type === \"naYesNo\") {\r\n    operatorId = \"isExtBool\";\r\n    argument = String(argument);\r\n  }\r\n\r\n  return {\r\n    id: uuid.v4(),\r\n    fieldId: otherField.id,\r\n    operatorId: operatorId,\r\n    argument: argument,\r\n    conjunctionOperator: conjunctionOperator,\r\n    type: type,\r\n    positionRule: position ? position : positionRule,\r\n    isInternal: true,\r\n  };\r\n}\r\n\r\nfunction convertRuleArgument(argType, argument, field) {\r\n  switch (argType) {\r\n    case \"bool\":\r\n      return argument === \"true\";\r\n    case \"extBool\":\r\n      assert([\"\", \"na\", \"fixed\", \"true\", \"false\"].includes(argument));\r\n      return argument;\r\n    case \"date\":\r\n      return moment(argument, \"YYYY-MM-DD\");\r\n    case \"number\":\r\n      return Number(argument);\r\n    case \"optionId\":\r\n      if (argument !== FREE_TEXT_VALUE) {\r\n        const otherOption = field.settings.options.find(\r\n          (option) => option.value === argument\r\n        );\r\n        return otherOption.value;\r\n      } else {\r\n        return argument;\r\n      }\r\n    // assert(false);\r\n    // return 42; // shut up eslint\r\n    case \"string\":\r\n      return argument;\r\n    default:\r\n      throw new Error(\"Unknown visibility rule argument type: \" + argType);\r\n  }\r\n}\r\n\r\nfunction readExtVisRules(fields, fieldNode, position) {\r\n  if (!fieldNode) {\r\n    return [];\r\n  }\r\n\r\n  if (hasChildNode(fieldNode, \"external_visibility_rules\")) {\r\n    const rulesNode = getChildNode(fieldNode, \"external_visibility_rules\");\r\n\r\n    return parseExtVisRulesNode(fields, rulesNode, position);\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction parseExtVisRulesNode(fields, node, position) {\r\n  assert(node.nodeName === \"external_visibility_rules\");\r\n\r\n  let positionRule = getLastPostionOfVisRules(fields, position);\r\n  const op = getAttrWithDefault(node, \"operator\", \"\");\r\n\r\n  const result = [];\r\n  result.operator = op;\r\n\r\n  if (node.hasChildNodes()) {\r\n    for (let i = 0; i < node.childNodes.length; i += 1) {\r\n      const child = node.childNodes[i];\r\n\r\n      switch (child.nodeName) {\r\n        case \"condition\":\r\n          positionRule = positionRule + 1;\r\n          var condition = parseExtConditionNode(fields, child, positionRule);\r\n          // condition.conjunctionOperator = condition.conjunctionOperator; // store conjuction operator to each condition\r\n          result.push(condition);\r\n          break;\r\n        case \"external_visibility_rules\":\r\n          result.push(parseExtVisRulesNode(fields, child, position));\r\n          break;\r\n        case \"#comment\": // fall thru\r\n        case \"#text\":\r\n          // ignore this\r\n          break;\r\n        default:\r\n          throw new Error(\r\n            \"external_visibility_rules element contains illegal child: \" +\r\n              child.nodeName\r\n          );\r\n      }\r\n    }\r\n  }\r\n\r\n  if (result.length <= 1) {\r\n    result.operator = \"and\";\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction getLastPostionOfVisRules(checkList, position) {\r\n  const getPositionVR = checkList[position].settings.visRules.map((rules) => {\r\n    return rules.positionRule;\r\n  });\r\n  return Math.max(...getPositionVR);\r\n}\r\n\r\nfunction parseExtConditionNode(checkList, node, positionRule) {\r\n  assert(node.nodeName === \"condition\");\r\n\r\n  const conditionNode = getChildNode(node, \"external_form\");\r\n  const deserializeResult = deserialize(conditionNode.textContent, true);\r\n\r\n  if (deserializeResult.error) {\r\n    const { error } = deserializeResult;\r\n    throw new Error(\"external_visibility_rules error: \" + error);\r\n  }\r\n\r\n  const { form, fields } = deserializeResult;\r\n\r\n  const otherIdentifier = getRequiredAttr(node, \"field-identifier\");\r\n  const otherFields = fields.filter(\r\n    (f) => f.settings.identifier === otherIdentifier\r\n  );\r\n  if (otherFields.length !== 1) {\r\n    throw new Error(\r\n      \"Invalid SFDL: Form contains multiple fields with the same identifier: \" +\r\n        otherIdentifier\r\n    );\r\n  }\r\n  const otherField = otherFields[0];\r\n\r\n  let operatorId = getRequiredAttr(node, \"operator\");\r\n  const argType = Ops[operatorId].argType;\r\n\r\n  let conjunctionOperator = getAttrWithDefault(\r\n    node,\r\n    \"conjunction-operator\",\r\n    \"and\"\r\n  );\r\n\r\n  let argument = convertRuleArgument(\r\n    argType,\r\n    getRequiredAttr(node, \"argument\"),\r\n    otherField\r\n  );\r\n\r\n  let position = parseInt(getAttrWithDefault(node, \"positionRule\", undefined));\r\n  // HACK to support opening old versions\r\n  if (operatorId === \"isBool\" && otherField.type === \"naYesNo\") {\r\n    operatorId = \"isExtBool\";\r\n    argument = String(argument);\r\n  }\r\n\r\n  return {\r\n    id: uuid.v4(),\r\n    fieldId: otherField.id,\r\n    operatorId: operatorId,\r\n    argument: argument,\r\n    conjunctionOperator: conjunctionOperator,\r\n    form: form,\r\n    fields: fields,\r\n    positionRule: position ? position : positionRule,\r\n    isInternal: false,\r\n  };\r\n}\r\n\r\nfunction readAuthorizationRules(authorizationUniverse, field, fieldNode) {\r\n  if (fieldNode === undefined) {\r\n    return [];\r\n  }\r\n\r\n  const findAuthorizationId = (name) => {\r\n    const authorization = authorizationUniverse.find((t) => t.name === name);\r\n    return authorization.id;\r\n  };\r\n\r\n  if (hasChildNode(fieldNode, \"authorization_rules\")) {\r\n    const rulesNode = getChildNode(fieldNode, \"authorization_rules\");\r\n    const alwaysAddNodes = getChildNodes(rulesNode, \"authorization\");\r\n\r\n    const alwaysAddRules = alwaysAddNodes.map((tagNode) => {\r\n      const authorizationName = getRequiredAttr(tagNode, \"name\");\r\n      const authorizationId = findAuthorizationId(authorizationName);\r\n      return {\r\n        id: uuid.v4(),\r\n        authorizationId: authorizationId,\r\n        authorizationName: authorizationName,\r\n      };\r\n    });\r\n\r\n    return alwaysAddRules;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction readTagRules(tagUniverse, field, fieldNode) {\r\n  if (fieldNode === undefined) {\r\n    return [];\r\n  }\r\n\r\n  const findTagId = (name) => {\r\n    const tag = tagUniverse.find((t) => t.name === name);\r\n    assert(tag);\r\n    return tag.id;\r\n  };\r\n\r\n  if (hasChildNode(fieldNode, \"tag_rules\")) {\r\n    const rulesNode = getChildNode(fieldNode, \"tag_rules\");\r\n\r\n    const ruleNodes = getChildNodes(rulesNode, \"tag_rule\");\r\n    const alwaysAddNodes = getChildNodes(rulesNode, \"tag\");\r\n\r\n    const alwaysAddRules = alwaysAddNodes.map((tagNode) => {\r\n      const tagName = getRequiredAttr(tagNode, \"name\");\r\n      const tagId = findTagId(tagName);\r\n      const operator = FieldTypes[field.type].applicableOperators[0];\r\n      return {\r\n        id: uuid.v4(),\r\n        tagId: tagId,\r\n        operatorId: operator.id,\r\n        argument: getDefaultValue(operator.argType, field),\r\n        alwaysAdd: true,\r\n      };\r\n    });\r\n\r\n    const normalRules = ruleNodes.map((ruleNode) => {\r\n      const tagName = getRequiredAttr(ruleNode, \"tag\");\r\n      const tagId = findTagId(tagName);\r\n      const operatorId = getRequiredAttr(ruleNode, \"operator\");\r\n      const argType = Ops[operatorId].argType;\r\n      const argument = convertRuleArgument(\r\n        argType,\r\n        getRequiredAttr(ruleNode, \"argument\"),\r\n        field\r\n      );\r\n\r\n      return {\r\n        id: uuid.v4(),\r\n        tagId: tagId,\r\n        operatorId: operatorId,\r\n        argument: argument,\r\n        alwaysAdd: false,\r\n      };\r\n    });\r\n\r\n    return alwaysAddRules.concat(normalRules);\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction readPrintTagRules(printTagUniverse, field, fieldNode) {\r\n  if (fieldNode === undefined) {\r\n    return [];\r\n  }\r\n\r\n  const findTagId = (name) => {\r\n    const tag = printTagUniverse.find((t) => t.name === name);\r\n    return tag.id;\r\n  };\r\n\r\n  if (hasChildNode(fieldNode, \"print_tag_rules\")) {\r\n    const rulesNode = getChildNode(fieldNode, \"print_tag_rules\");\r\n    const alwaysAddNodes = getChildNodes(rulesNode, \"tag\");\r\n\r\n    const alwaysAddRules = alwaysAddNodes.map((tagNode) => {\r\n      const tagName = getRequiredAttr(tagNode, \"name\");\r\n      const tagId = findTagId(tagName);\r\n      return {\r\n        id: uuid.v4(),\r\n        tagId: tagId,\r\n        tagName: tagName,\r\n      };\r\n    });\r\n\r\n    return alwaysAddRules;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction readButtonDescriptions(fields, fieldNode) {\r\n  if (hasChildNode(fieldNode, \"button_descriptions\")) {\r\n    const buttonDescriptionsNode = getChildNode(\r\n      fieldNode,\r\n      \"button_descriptions\"\r\n    );\r\n\r\n    return parseButtonDescriptionNode(fields, buttonDescriptionsNode);\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction parseButtonDescriptionNode(fields, node) {\r\n  assert(node.nodeName === \"button_descriptions\");\r\n\r\n  const result = [];\r\n\r\n  if (node.hasChildNodes()) {\r\n    for (let i = 0; i < node.childNodes.length; i += 1) {\r\n      const child = node.childNodes[i];\r\n\r\n      if (child.nodeName === \"#comment\" || child.nodeName === \"#text\") {\r\n        continue;\r\n      }\r\n\r\n      const selectedDescriptionId = getRequiredAttr(\r\n        child,\r\n        \"selected-description-id\"\r\n      );\r\n      const selectedButtonId = getRequiredAttr(child, \"selected-button-id\");\r\n\r\n      if (child.nodeName === \"button_description\") {\r\n        result.push({\r\n          id: uuid.v4(),\r\n          selectedDescriptionId: selectedDescriptionId,\r\n          selectedButtonId: selectedButtonId,\r\n        });\r\n      } else {\r\n        throw new Error(\r\n          \"button_descriptions element contains illegal child: \" +\r\n            child.nodeName\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}